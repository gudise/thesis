%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{myfpga}
\date{Dec 13, 2023}
\release{2.94}
\author{Guillermo Díez\sphinxhyphen{}Señorans}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{myfpga package}
\label{\detokenize{myfpga:myfpga-package}}\label{\detokenize{myfpga::doc}}

\section{Submodules}
\label{\detokenize{myfpga:submodules}}

\section{myfpga.fabric module}
\label{\detokenize{myfpga:module-myfpga.fabric}}\label{\detokenize{myfpga:myfpga-fabric-module}}\index{module@\spxentry{module}!myfpga.fabric@\spxentry{myfpga.fabric}}\index{myfpga.fabric@\spxentry{myfpga.fabric}!module@\spxentry{module}}
\sphinxAtStartPar
Este módulo contiene una lista de algunos recursos relacionados con la 
estructura interna de la FPGA; estas cantidades son invariantes (no se
modifican durante la ejecución de un programa).


\section{myfpga.interfaz\_pcps module}
\label{\detokenize{myfpga:module-myfpga.interfaz_pcps}}\label{\detokenize{myfpga:myfpga-interfaz-pcps-module}}\index{module@\spxentry{module}!myfpga.interfaz\_pcps@\spxentry{myfpga.interfaz\_pcps}}\index{myfpga.interfaz\_pcps@\spxentry{myfpga.interfaz\_pcps}!module@\spxentry{module}}\index{bitstr\_to\_bytestr() (in module myfpga.interfaz\_pcps)@\spxentry{bitstr\_to\_bytestr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.bitstr_to_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bitstr\_to\_bytestr}}}{\sphinxparam{\DUrole{n}{bitstr\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Toma una lista de bits (bitstr\_in) de tamaño ‘bitstr\_width’
y la convierte a una lista de bytes del tamaño mínimo
necesario para alojar la entrada.

\end{fulllineitems}

\index{bitstr\_to\_int() (in module myfpga.interfaz\_pcps)@\spxentry{bitstr\_to\_int()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.bitstr_to_int}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bitstr\_to\_int}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Convierte una lista de bits en su
correspondiente numero decimal (entero)

\end{fulllineitems}

\index{bytestr\_to\_bitstr() (in module myfpga.interfaz\_pcps)@\spxentry{bytestr\_to\_bitstr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.bytestr_to_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bytestr\_to\_bitstr}}}{\sphinxparam{\DUrole{n}{bytestr}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Toma una lista de bytes y los aloja en una lista de bits
de tamaño ‘bitstr\_width’. Si ‘bitstr\_width’ es insuficiente,
la lista de bits se truncará.

\end{fulllineitems}

\index{bytestr\_to\_int() (in module myfpga.interfaz\_pcps)@\spxentry{bytestr\_to\_int()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.bytestr_to_int}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bytestr\_to\_int}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Convierte una lista de bytes en su
correspondiente numero decimal (entero)

\end{fulllineitems}

\index{calc() (in module myfpga.interfaz\_pcps)@\spxentry{calc()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.calc}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{calc}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion dispara un ciclo RDY\sphinxhyphen{}\textgreater{}CALC\sphinxhyphen{}\textgreater{}PRINT\sphinxhyphen{}\textgreater{}RDY
a una fsm conectada a traves de ‘serialport’
y devuelve un bitstr de tamaño ‘buffer\_out\_width’

\end{fulllineitems}

\index{int\_to\_bitstr() (in module myfpga.interfaz\_pcps)@\spxentry{int\_to\_bitstr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.int_to_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{int\_to\_bitstr}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion convierte un numero ‘entrada’ en un bitstr
(i.e. en su representacion en base 2). Como siempre, el
numero mas a la dcha del bitstr (result{[}0{]}) es el menos
significativo

\end{fulllineitems}

\index{int\_to\_bytestr() (in module myfpga.interfaz\_pcps)@\spxentry{int\_to\_bytestr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.int_to_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{int\_to\_bytestr}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion convierte un numero ‘entrada’ en un bytestr
(i.e. en su representacion en base 256). Como siempre,
el numero mas a la dcha del bytestr (result{[}0{]})
es el menos significativo

\end{fulllineitems}

\index{print\_bitstr() (in module myfpga.interfaz\_pcps)@\spxentry{print\_bitstr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.print_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{print\_bitstr}}}{\sphinxparam{\DUrole{n}{bitstr\_in}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{print\_bytestr() (in module myfpga.interfaz\_pcps)@\spxentry{print\_bytestr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.print_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{print\_bytestr}}}{\sphinxparam{\DUrole{n}{bytestr\_in}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{receive\_bytestr() (in module myfpga.interfaz\_pcps)@\spxentry{receive\_bytestr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.receive_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_bytestr}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bytestr\_size}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Recibe ‘bytestr\_size’ bytes a traves del puerto serie ‘serialport’

\end{fulllineitems}

\index{receive\_u32() (in module myfpga.interfaz\_pcps)@\spxentry{receive\_u32()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.receive_u32}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_u32}}}{\sphinxparam{\DUrole{n}{serialport}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion implementa un bucle para leer 4 bytes del puerto serie
‘serialport’, y los devuelve en formato u32 (entero). Si no habia
datos en el buffer de entrada a la hora de llamar a la funcion
devuelve \sphinxhyphen{}1

\end{fulllineitems}

\index{receive\_u8() (in module myfpga.interfaz\_pcps)@\spxentry{receive\_u8()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.receive_u8}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_u8}}}{\sphinxparam{\DUrole{n}{serialport}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion implementa un bucle para leer 1 byte del puerto serie
‘serialport’, y devuelve dicho byte en formato u8 (un numero entre 0 y 255).
Si no habia datos en el buffer de entrada a la hora de llamar a la
funcion devuelve \sphinxhyphen{}1

\end{fulllineitems}

\index{resize\_array() (in module myfpga.interfaz\_pcps)@\spxentry{resize\_array()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.resize_array}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{resize\_array}}}{\sphinxparam{\DUrole{n}{array\_old}}\sphinxparamcomma \sphinxparam{\DUrole{n}{array\_size}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion toma un array\_old de tamano arbitrario y transfiere
los caracteres a un array de tamano nbits, empezando por el
caracter menos significativo (a la dcha.). Si nbits no es
suficiente para contener todo el array\_old, la salida estara
truncada. Si nbits es excesivo para contener array\_old,
los huecos que sobren se rellenan con ceros.

\end{fulllineitems}

\index{scan() (in module myfpga.interfaz\_pcps)@\spxentry{scan()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.scan}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{scan}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_in\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion dispara un ciclo RDY\sphinxhyphen{}\textgreater{}SCAN\sphinxhyphen{}\textgreater{}RDY
a una fsm conectada a traves de ‘serialport’
y sube un bitstr de tamaño ‘buffer\_in\_width’

\end{fulllineitems}

\index{send\_bytestr() (in module myfpga.interfaz\_pcps)@\spxentry{send\_bytestr()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.send_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{send\_bytestr}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bytestr\_out}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Envía ‘bytestr\_out’ bytes a traves del puerto serie ‘serialport’

\end{fulllineitems}

\index{send\_u8() (in module myfpga.interfaz\_pcps)@\spxentry{send\_u8()}\spxextra{in module myfpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.interfaz_pcps.send_u8}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{send\_u8}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{number}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion envia un numero en formato u8
a traves de ‘serialport’. Si ‘number’ es
mayor que 256, se enviará el resto: number\%256

\end{fulllineitems}



\section{myfpga.ring\_osc module}
\label{\detokenize{myfpga:module-myfpga.ring_osc}}\label{\detokenize{myfpga:myfpga-ring-osc-module}}\index{module@\spxentry{module}!myfpga.ring\_osc@\spxentry{myfpga.ring\_osc}}\index{myfpga.ring\_osc@\spxentry{myfpga.ring\_osc}!module@\spxentry{module}}
\sphinxAtStartPar
Este módulo contiene una serie de clases y funciones para implementar y
medir una matriz de osciladores de anillo en FPGA, tanto estándar como
de Galois.
\index{Dominio (class in myfpga.ring\_osc)@\spxentry{Dominio}\spxextra{class in myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.Dominio}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{Dominio}}}{\sphinxparam{\DUrole{n}{N\_osc}\DUrole{o}{=}\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x1}\DUrole{o}{=}\DUrole{default_value}{inf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dx}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y0}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y1}\DUrole{o}{=}\DUrole{default_value}{inf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{directriz}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}y\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Este objeto contiene las localizaciones de un conjunto de 
osciladores dispuestos atendiendo a diversos parámetros geométricos.
Si directriz=y, estos se colocan formando una matriz rectangular, la cual crece en
dirección y en incrementos de dy. Cuando se alcanza el límite y1, la matriz se incrementa
una cantidad dx en la dirección x, y vuelve a la coordenada y0. Si directriz=x, el 
comentario anterior se aplica substituyendo x \textless{}\sphinxhyphen{}\textgreater{} y.


\subsection{Variables:}
\label{\detokenize{myfpga:variables}}
\sphinxAtStartPar
osc\_coord : coordenadas de los osciladores.
\index{help() (myfpga.ring\_osc.Dominio method)@\spxentry{help()}\spxextra{myfpga.ring\_osc.Dominio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.Dominio.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘Dominio’.

\end{fulllineitems}


\end{fulllineitems}

\index{GaloisMatrix (class in myfpga.ring\_osc)@\spxentry{GaloisMatrix}\spxextra{class in myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{GaloisMatrix}}}{\sphinxparam{\DUrole{n}{N\_inv=3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dominios=\textless{}myfpga.ring\_osc.Dominio object\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl=False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{trng=0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly=\sphinxhyphen{}1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{inverted\_end=True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Objeto que contiene una matriz de osciladores de anillo de Galois.
\index{gen\_garomatrix() (myfpga.ring\_osc.GaloisMatrix method)@\spxentry{gen\_garomatrix()}\spxextra{myfpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix.gen_garomatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_garomatrix}}}{\sphinxparam{\DUrole{n}{out\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}garomatrix.v\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Genera un diseño ‘out\_name’ en formato Verilog con la implementación de 
los dominios introducidos durante la inicialización del objeto. El 
principal uso de esta función es dentro de la función ‘implement()’.


\subsection{Parámetros:}
\label{\detokenize{myfpga:parametros}}\begin{quote}
\begin{description}
\sphinxlineitem{out\_name}{[}\textless{}string\textgreater{} (opcional){]}
\sphinxAtStartPar
Nombre del fichero de salida.

\end{description}
\end{quote}

\end{fulllineitems}

\index{help() (myfpga.ring\_osc.GaloisMatrix method)@\spxentry{help()}\spxextra{myfpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘GaloisMatrix’.

\end{fulllineitems}

\index{implement() (myfpga.ring\_osc.GaloisMatrix method)@\spxentry{implement()}\spxextra{myfpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix.implement}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{implement}}}{\sphinxparam{\DUrole{n}{projname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}project\_garomatrix\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{projdir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{njobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{files}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{board}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pynqz2\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qspi}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{routing}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pblock}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}\DUrole{o}{=}\DUrole{default_value}{32}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Copia en el directorio ‘self.projdir’ todos los archivos necesarios para 
implementar una matriz de osciladores de anillo de Galois con medición 
del sesgo (“bias”) y comunicación pc \textless{}\sphinxhyphen{}\textgreater{} microprocesador \textless{}\sphinxhyphen{}\textgreater{} FPGA.


\subsection{Parámetros:}
\label{\detokenize{myfpga:id1}}\begin{quote}
\begin{description}
\sphinxlineitem{projname}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Nombre del proyecto de Vivado.

\sphinxlineitem{projdir}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Directorio donde se creará el proyecto de Vivado y las fuentes (por
defecto el directorio de trabajo actual).

\sphinxlineitem{njobs}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Número de núcleos que utiilizará Vivado paralelamente para la 
síntesis/implementación.

\sphinxlineitem{debug}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, se implementará una matriz de divisores de reloj de 
frecuencia conocida, lo que permite depurar el diseño al conocer
qué resultados deben salir.

\sphinxlineitem{files}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, pinta los archivos necesarios para implementar la 
matriz en FPGA. Esta opción se puede desactivar (False) cuando 
queremos configurar un objeto tipo ‘Romatrix’ pero no vamos a 
implementarla físicamente (por ejemplo porque ya lo hemos hecho
y solo queremos medir, o vamos a simularla sin realizarla).

\sphinxlineitem{board}{[}\textless{}string\textgreater{} {]}
\sphinxAtStartPar
Placa de desarrollo utilizada en el proyecyo. Las opciones 
soportadas son: ‘pynqz2’, ‘zybo’, ‘cmoda7\_15t’ o ‘cmoda7\_35t’.

\sphinxlineitem{qspi}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, el flujo de diseño incluirá el guardado del bitstream
en la memoria flash de la placa para que se auto\sphinxhyphen{}programe al 
encenderse.

\sphinxlineitem{routing}{[}\textless{}bool\textgreater{} {]}
\sphinxAtStartPar
Si “True”, el flujo de diseño incluirá el cableado de los 
inversores después de la síntesis. Esto aumenta las 
probabilidades de que la herramienta haga un cableado idéntico,
pero es recomendable comprobarlo. (NOTA: no tengo garantías de 
que esta opción sea del todo compatible con \sphinxhyphen{}qspi).

\sphinxlineitem{pblock}{[}\textless{}bool, por defecto False\textgreater{}{]}
\sphinxAtStartPar
Si esta opción es ‘True’ se inserta la matriz en un pblock tal que
el espacio dentro del bloque se excluye para toda lógica que no sea
la propia matriz.

\sphinxlineitem{data\_width}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Esta opción especifica la anchura del canal de datos PS\textless{}\textendash{}\textgreater{}PL.

\sphinxlineitem{buffer\_out\_width}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Esta opción especifica la anchura de la palabra de respuesta 
(i.e., de la medida).

\end{description}
\end{quote}

\end{fulllineitems}

\index{medir() (myfpga.ring\_osc.GaloisMatrix method)@\spxentry{medir()}\spxextra{myfpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix.medir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{medir}}}{\sphinxparam{\DUrole{n}{puerto}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}/dev/ttyS1\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{osc}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{resol}\DUrole{o}{=}\DUrole{default_value}{14}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fdiv}\DUrole{o}{=}\DUrole{default_value}{9}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bias}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{log}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baudrate}\DUrole{o}{=}\DUrole{default_value}{9600}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función mide la frecuencia de una matriz de osciladores de Galois 
‘GaloisMatrix’, una vez esta ha sido implementado en FPGA. El resultado
se devuelve como un objeto ‘Tensor’.


\subsection{Parámetros:}
\label{\detokenize{myfpga:id2}}\begin{quote}
\begin{description}
\sphinxlineitem{puerto}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Esta opción especifica el puerto serie al que se conecta la 
FPGA.

\sphinxlineitem{osc}{[}\textless{}int o lista de int\textgreater{}{]}
\sphinxAtStartPar
Lista de osciladores a medir.

\sphinxlineitem{pdl}{[}\textless{}int o lista de int\textgreater{}{]}
\sphinxAtStartPar
Lista de PDL a medir.

\sphinxlineitem{N\_rep}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Número de repeticiones a medir.

\sphinxlineitem{resol}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
log\_2 del número de ciclos de referencia a completar para dar 
por terminada la medida (por defecto 14, i.e., 2\textasciicircum{}14 = 16384 
ciclos).

\sphinxlineitem{poly}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Esta variable indica el índice del polinomio a medir.

\sphinxlineitem{fdiv}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
log\_2 del factor de división menos uno, para el reloj de muestreo
(por defecto 9, i.e., 2\textasciicircum{}(9+1)=1024; cin f\_ref=100 MHz esto supone
una frecuencia de muestre f\_s=97.65 kHz).

\sphinxlineitem{bias}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si se pasa esta opción como “True” el resultado se dará en 
tanto por 1.

\sphinxlineitem{log}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si se pasa “True” se escriben algunos datos a modo de log.

\sphinxlineitem{verbose}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si se pasa “True” se pinta una barra de progreso de la medida. 
Desactivar esta opción (“False”) hace más cómodo utilizar esta 
función en un bucle.

\sphinxlineitem{baudrate}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Tasa de transferencia del protocolo serie UART PC\textless{}\textendash{}\textgreater{}PS. Debe 
concordar con el programa compilador en PS.

\end{description}
\end{quote}

\end{fulllineitems}

\index{save() (myfpga.ring\_osc.GaloisMatrix method)@\spxentry{save()}\spxextra{myfpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisMatrix.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para guardar objetos serializados con el módulo ‘pickle’.

\end{fulllineitems}


\end{fulllineitems}

\index{GaloisRing (class in myfpga.ring\_osc)@\spxentry{GaloisRing}\spxextra{class in myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisRing}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{GaloisRing}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{inverted\_end}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Lista de elementos (LUT) que constituyen un oscilador de anillo
de Galois junto con la información necesaria para su implementación
en FPGA utilzando el software ‘Vivado’.
\begin{description}
\sphinxlineitem{Un anillo ‘GaloisRing’ consta de N\_inv+2 elementos:}
\sphinxAtStartPar
. Inversor inicial.
. N\_inv\sphinxhyphen{}1 elementos inversores/XNOR.
. Inversor de salida.
. flip\sphinxhyphen{}flop de muestreo.

\end{description}
\index{help() (myfpga.ring\_osc.GaloisRing method)@\spxentry{help()}\spxextra{myfpga.ring\_osc.GaloisRing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.GaloisRing.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘GaloisRing’.

\end{fulllineitems}


\end{fulllineitems}

\index{StdMatrix (class in myfpga.ring\_osc)@\spxentry{StdMatrix}\spxextra{class in myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{StdMatrix}}}{\sphinxparam{\DUrole{n}{N\_inv=3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dominios=\textless{}myfpga.ring\_osc.Dominio object\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl=False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Objeto que contiene una matriz de osciladores de anillo estándar.


\subsection{Parámetros:}
\label{\detokenize{myfpga:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{N\_inv}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Número de inversores de cada oscilador.

\sphinxlineitem{dominios}{[}\textless{}objeto ‘Dominio’ o lista de estos\textgreater{}{]}
\sphinxAtStartPar
Osciladores que forman la matriz. Se construye como una lista de 
objetos ‘Dominio’. Si solo pasamos un dominio de osciladores podemos
pasar un objeto ‘Dominio’, en lugar de una lista.

\sphinxlineitem{bel}{[}\textless{}caracter o lista de caracteres\textgreater{}{]}
\sphinxAtStartPar
Dado que todos los anillos de la matriz son idénticos 
por diseño, esta opción es la misma que la aplicada para
un solo oscilador (ver ‘bel’ en ‘StdRing’).

\sphinxlineitem{pin}{[}\textless{}cadena de caracteres o lista de cadenas\textgreater{}{]}
\sphinxAtStartPar
Dado que todos los anillos de la matriz son idénticos 
por diseño, esta opción es la misma que la aplicada para
un solo oscilador (ver ‘pin’ en ‘StdRing’).

\sphinxlineitem{pdl}{[}\textless{}bool, opcional, por defecto False\textgreater{}{]}
\sphinxAtStartPar
Si ‘True’ se utilizan modelos LUT6 para los inversores, permitiendo 
utilizar 5 puertos para configurar el anillo mediante PDL. Si ‘False’ 
se utilizan modelos LUT1 para los inversores y LUT2 para el enable AND.

\end{description}
\end{quote}
\index{gen\_romatrix() (myfpga.ring\_osc.StdMatrix method)@\spxentry{gen\_romatrix()}\spxextra{myfpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix.gen_romatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_romatrix}}}{\sphinxparam{\DUrole{n}{out\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}romatrix.v\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Genera un diseño ‘out\_name’ en formato Verilog con la implementación de 
los dominios introducidos durante la inicialización del objeto. El 
principal uso de esta función es dentro de la función ‘implement()’.


\subsubsection{Parámetros:}
\label{\detokenize{myfpga:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{out\_name}{[}\textless{}string\textgreater{} (opcional){]}
\sphinxAtStartPar
Nombre del fichero de salida.

\sphinxlineitem{debug}{[}\textless{}bool\textgreater{} (opcional){]}
\sphinxAtStartPar
Flag que indica si se debe geenrar un diseño de depuración en 
lugar de una verdadera matriz de osciladores de anillo. En el 
diseño de depuración se substituye cada anillo por un divisor de
reloj de frecuencia conocida, lo que permite depurar la interfaz
de medida.

\end{description}
\end{quote}

\end{fulllineitems}

\index{help() (myfpga.ring\_osc.StdMatrix method)@\spxentry{help()}\spxextra{myfpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘StdMatrix’.

\end{fulllineitems}

\index{implement() (myfpga.ring\_osc.StdMatrix method)@\spxentry{implement()}\spxextra{myfpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix.implement}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{implement}}}{\sphinxparam{\DUrole{n}{projname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}project\_romatrix\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{projdir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{njobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{files}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{board}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pynqz2\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qspi}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{routing}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pblock}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_clock}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Copia en el directorio ‘self.projdir’ todos los archivos necesarios para 
implementar una matriz de osciladores de anillo con medición de la 
frecuencia y comunicación pc \textless{}\sphinxhyphen{}\textgreater{} microprocesador \textless{}\sphinxhyphen{}\textgreater{} FPGA.


\subsubsection{Parámetros:}
\label{\detokenize{myfpga:id5}}\begin{quote}
\begin{description}
\sphinxlineitem{projname}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Nombre del proyecto de Vivado.

\sphinxlineitem{projdir}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Directorio donde se creará el proyecto de Vivado y las fuentes (por
defecto el directorio de trabajo actual).

\sphinxlineitem{njobs}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Número de núcleos que utiilizará Vivado paralelamente para la 
síntesis/implementación.

\sphinxlineitem{debug}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, se implementará una matriz de divisores de reloj de 
frecuencia conocida, lo que permite depurar el diseño al conocer
qué resultados deben salir.

\sphinxlineitem{files}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, pinta los archivos necesarios para implementar la 
matriz en FPGA. Esta opción se puede desactivar (False) cuando 
queremos configurar un objeto tipo ‘Romatrix’ pero no vamos a 
implementarla físicamente (por ejemplo porque ya lo hemos hecho
y solo queremos medir, o vamos a simularla sin realizarla).

\sphinxlineitem{board}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Placa de desarrollo utilizada en el proyecyo. Las opciones 
soportadas son: ‘pynqz2’, ‘zybo’, ‘cmoda7\_15t’ o ‘cmoda7\_35t’.

\sphinxlineitem{qspi}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, el flujo de diseño incluirá el guardado del bitstream
en la memoria flash de la placa para que se auto\sphinxhyphen{}programe al 
encenderse.

\sphinxlineitem{routing}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si “True”, el flujo de diseño incluirá el cableado de los 
inversores después de la síntesis. Esto aumenta las 
probabilidades de que la herramienta haga un cableado idéntico,
pero es recomendable comprobarlo. (NOTA: no tengo garantías de 
que esta opción sea del todo compatible con \sphinxhyphen{}qspi).

\sphinxlineitem{pblock}{[}\textless{}bool, por defecto False\textgreater{}{]}
\sphinxAtStartPar
Si esta opción es ‘True’ se inserta la matriz en un pblock tal que
el espacio dentro del bloque se excluye para toda lógica que no sea
la propia matriz.

\sphinxlineitem{data\_width(dw)}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Esta opción especifica la anchura del canal de datos PS\textless{}\textendash{}\textgreater{}PL.

\sphinxlineitem{buffer\_out\_width(bow)}{[}\textless{}int\textgreater{} {]}
\sphinxAtStartPar
Esta opción especifica la anchura de la palabra de respuesta 
(i.e., de la medida).

\sphinxlineitem{f\_clock}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Frecuencia del reloj del diseño (en MHz).

\end{description}
\end{quote}

\end{fulllineitems}

\index{medir() (myfpga.ring\_osc.StdMatrix method)@\spxentry{medir()}\spxextra{myfpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix.medir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{medir}}}{\sphinxparam{\DUrole{n}{puerto}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}/dev/ttyS1\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{osc}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{resol}\DUrole{o}{=}\DUrole{default_value}{17}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_ref}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{log}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baudrate}\DUrole{o}{=}\DUrole{default_value}{9600}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función mide la frecuencia de una matriz de osciladores estándar 
‘StdMatrix’, una vez esta ha sido implementado en FPGA. El resultado 
se devuelve como un objeto ‘Tensor’.


\subsubsection{Parámetros:}
\label{\detokenize{myfpga:id6}}\begin{quote}
\begin{description}
\sphinxlineitem{puerto}{[}\textless{}string\textgreater{}{]}
\sphinxAtStartPar
Esta opción especifica el puerto serie al que se conecta la 
FPGA.

\sphinxlineitem{osc}{[}\textless{}int o lista de int\textgreater{}{]}
\sphinxAtStartPar
Lista de osciladores a medir.

\sphinxlineitem{pdl}{[}\textless{}int o lista de int\textgreater{}{]}
\sphinxAtStartPar
Lista de PDL a medir.

\sphinxlineitem{N\_rep}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Número de repeticiones a medir.

\sphinxlineitem{resol}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
log\_2 del número de ciclos de referencia a completar para dar 
por terminada la medida (por defecto 17, i.e., 2\textasciicircum{}17 = 131072 
ciclos).

\sphinxlineitem{f\_ref = \textless{}real\textgreater{}}
\sphinxAtStartPar
Frecuencia del reloj de referencia. Si se proporciona este 
valor, el resultado obtenido se devuelve en las mismas unidades
en que se haya pasado este valor “f\_ref”.

\sphinxlineitem{log}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si se pasa “True” se escriben algunos datos a modo de log.

\sphinxlineitem{verbose}{[}\textless{}bool\textgreater{}{]}
\sphinxAtStartPar
Si se pasa “True” se pinta una barra de progreso de la medida. 
Desactivar esta opción (“False”) hace más cómodo utilizar esta 
función en un bucle.

\sphinxlineitem{baudrate}{[}\textless{}int\textgreater{}{]}
\sphinxAtStartPar
Tasa de transferencia del protocolo serie UART PC\textless{}\textendash{}\textgreater{}PS. Debe 
concordar con el programa compilador en PS.

\end{description}
\end{quote}

\end{fulllineitems}

\index{save() (myfpga.ring\_osc.StdMatrix method)@\spxentry{save()}\spxextra{myfpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdMatrix.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para guardar objetos serializados con el módulo ‘pickle’.

\end{fulllineitems}


\end{fulllineitems}

\index{StdRing (class in myfpga.ring\_osc)@\spxentry{StdRing}\spxextra{class in myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdRing}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{StdRing}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Lista de elementos (LUT) que constituyen un oscilador de anillo
estándar junto con la información necesaria para su implementación
en FPGA utilzando el software ‘Vivado’.
\begin{description}
\sphinxlineitem{Un anillo ‘StdRing’ consta de N\_inv+1 elementos:}
\sphinxAtStartPar
. Puerta AND.
. N\_inv inversores.

\end{description}
\index{help() (myfpga.ring\_osc.StdRing method)@\spxentry{help()}\spxextra{myfpga.ring\_osc.StdRing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.StdRing.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘StdRing’.

\end{fulllineitems}


\end{fulllineitems}

\index{clog2() (in module myfpga.ring\_osc)@\spxentry{clog2()}\spxextra{in module myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.clog2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{clog2}}}{\sphinxparam{\DUrole{n}{N}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Numero de bits necesarios para especificar ‘N’ estados.

\end{fulllineitems}

\index{load() (in module myfpga.ring\_osc)@\spxentry{load()}\spxextra{in module myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.load}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{load}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para la función ‘load’ del módulo
‘pickle’, que permite cargar un objeto guardado serializado de
cualquier clase.

\end{fulllineitems}

\index{np\_normal() (in module myfpga.ring\_osc)@\spxentry{np\_normal()}\spxextra{in module myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.np_normal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{np\_normal}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
normal(loc=0.0, scale=1.0, size=None)

\sphinxAtStartPar
Draw random samples from a normal (Gaussian) distribution.

\sphinxAtStartPar
The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently {\color{red}\bfseries{}{[}2{]}\_}, is often called the bell curve because of
its characteristic shape (see the example below).

\sphinxAtStartPar
The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution {\color{red}\bfseries{}{[}2{]}\_}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
New code should use the \sphinxtitleref{\textasciitilde{}numpy.random.Generator.normal}
method of a \sphinxtitleref{\textasciitilde{}numpy.random.Generator} instance instead;
please see the \DUrole{xref,std,std-ref}{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}


\subsection{Parameters}
\label{\detokenize{myfpga:parameters}}\begin{description}
\sphinxlineitem{loc}{[}float or array\_like of floats{]}
\sphinxAtStartPar
Mean (“centre”) of the distribution.

\sphinxlineitem{scale}{[}float or array\_like of floats{]}
\sphinxAtStartPar
Standard deviation (spread or “width”) of the distribution. Must be
non\sphinxhyphen{}negative.

\sphinxlineitem{size}{[}int or tuple of ints, optional{]}
\sphinxAtStartPar
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}


\subsection{Returns}
\label{\detokenize{myfpga:returns}}\begin{description}
\sphinxlineitem{out}{[}ndarray or scalar{]}
\sphinxAtStartPar
Drawn samples from the parameterized normal distribution.

\end{description}


\subsection{See Also}
\label{\detokenize{myfpga:see-also}}\begin{description}
\sphinxlineitem{scipy.stats.norm}{[}probability density function, distribution or{]}
\sphinxAtStartPar
cumulative density function, etc.

\end{description}

\sphinxAtStartPar
random.Generator.normal: which should be used for new code.


\subsection{Notes}
\label{\detokenize{myfpga:notes}}
\sphinxAtStartPar
The probability density for the Gaussian distribution is
\begin{equation*}
\begin{split}p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu\) is the mean and \(\sigma\) the standard
deviation. The square of the standard deviation, \(\sigma^2\),
is called the variance.

\sphinxAtStartPar
The function has its peak at the mean, and its “spread” increases with
the standard deviation (the function reaches 0.607 times its maximum at
\(x + \sigma\) and \(x - \sigma\) {\color{red}\bfseries{}{[}2{]}\_}).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.


\subsection{References}
\label{\detokenize{myfpga:references}}

\subsection{Examples}
\label{\detokenize{myfpga:examples}}
\sphinxAtStartPar
Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} mean and standard deviation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Verify the mean and the variance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{mu} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.1  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\sphinxAtStartPar
Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
\PYG{g+gp}{... }               \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from the normal distribution with
mean 3 and standard deviation 2.5:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{sim\_romatrix() (in module myfpga.ring\_osc)@\spxentry{sim\_romatrix()}\spxextra{in module myfpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.ring_osc.sim_romatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{sim\_romatrix}}}{\sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_pdl}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_osc}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_pdl}\DUrole{o}{=}\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_osc}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función proporciona un simulador naíf de una matriz de celdas; reproduce
las medidas de una instancia para un número de repeticiones (N\_rep), pdl (N\_pdl)
y celdas (N\_osc), así como ajustar las desviaciones estándar de cada proceso.
El comportamiento estándar es:
\begin{quote}

\sphinxAtStartPar
std\_rep\textless{}std\_pdl\textless{}std\_osc
\end{quote}

\sphinxAtStartPar
La función genera los valores aleatorios como una distribución normal, pero
luego los escala para devolver siempre valores enteros positivos.


\subsection{Parámetros:}
\label{\detokenize{myfpga:id12}}\begin{description}
\sphinxlineitem{N\_rep}{[}\textless{}int, opcional, por defecto 1\textgreater{}{]}
\sphinxAtStartPar
Número de repeticiones simuladas.

\sphinxlineitem{N\_pdl}{[}\textless{}int, opcional, por defecto 1\textgreater{}{]}
\sphinxAtStartPar
Número de PDL simulados.

\sphinxlineitem{N\_osc}{[}\textless{}int, opcional, por defecto 1\textgreater{}{]}
\sphinxAtStartPar
Número de celdas simuladas.

\sphinxlineitem{std\_rep}{[}\textless{}float, opcional, por defecto 1.0\textgreater{}{]}
\sphinxAtStartPar
Desviación estándar de una misma celda, para un mismo PDL entre
medidas sucesivas.

\sphinxlineitem{std\_pdl}{[}\textless{}float, opcional, por defecto 10.0\textgreater{}{]}
\sphinxAtStartPar
Desviación estandar de una misma celda entre distintos PDL

\sphinxlineitem{std\_osc}{[}\textless{}float, opcional, por defecto 100.0\textgreater{}{]}
\sphinxAtStartPar
Desviación estándar entre distintas celdas.

\end{description}

\end{fulllineitems}



\section{myfpga.sim\_lut module}
\label{\detokenize{myfpga:module-myfpga.sim_lut}}\label{\detokenize{myfpga:myfpga-sim-lut-module}}\index{module@\spxentry{module}!myfpga.sim\_lut@\spxentry{myfpga.sim\_lut}}\index{myfpga.sim\_lut@\spxentry{myfpga.sim\_lut}!module@\spxentry{module}}\index{LUT3 (class in myfpga.sim\_lut)@\spxentry{LUT3}\spxextra{class in myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.LUT3}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{LUT3}}}{\sphinxparam{\DUrole{n}{config\_ram}}\sphinxparamcomma \sphinxparam{\DUrole{n}{func\_pot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{O}}\sphinxparamcomma \sphinxparam{\DUrole{n}{I0}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}x\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{I1}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}x\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{I2}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}x\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{umbral}\DUrole{o}{=}\DUrole{default_value}{0.5}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mu}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sigma}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\end{fulllineitems}

\index{MODULO (class in myfpga.sim\_lut)@\spxentry{MODULO}\spxextra{class in myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.MODULO}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{MODULO}}}{\sphinxparam{\DUrole{n}{luts}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{probe() (myfpga.sim\_lut.MODULO method)@\spxentry{probe()}\spxextra{myfpga.sim\_lut.MODULO method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.MODULO.probe}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{probe}}}{\sphinxparam{\DUrole{n}{name}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{run() (myfpga.sim\_lut.MODULO method)@\spxentry{run()}\spxextra{myfpga.sim\_lut.MODULO method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.MODULO.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\sphinxparam{\DUrole{n}{t0}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{t1}\DUrole{o}{=}\DUrole{default_value}{100}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{waveform\_in}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{out}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{setw() (myfpga.sim\_lut.MODULO method)@\spxentry{setw()}\spxextra{myfpga.sim\_lut.MODULO method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.MODULO.setw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setw}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{step() (myfpga.sim\_lut.MODULO method)@\spxentry{step()}\spxextra{myfpga.sim\_lut.MODULO method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.MODULO.step}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step}}}{}{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{WAVEFORM (class in myfpga.sim\_lut)@\spxentry{WAVEFORM}\spxextra{class in myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.WAVEFORM}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{WAVEFORM}}}{\sphinxparam{\DUrole{n}{x}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{waves}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\end{fulllineitems}

\index{delayLineModel() (in module myfpga.sim\_lut)@\spxentry{delayLineModel()}\spxextra{in module myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.delayLineModel}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{delayLineModel}}}{\sphinxparam{\DUrole{n}{expected\_value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{old\_value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{func\_pot}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mu}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sigma}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{normal() (in module myfpga.sim\_lut)@\spxentry{normal()}\spxextra{in module myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.normal}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{normal}}}{\sphinxparam{\DUrole{n}{loc}\DUrole{o}{=}\DUrole{default_value}{0.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Draw random samples from a normal (Gaussian) distribution.

\sphinxAtStartPar
The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently {\color{red}\bfseries{}{[}2{]}\_}, is often called the bell curve because of
its characteristic shape (see the example below).

\sphinxAtStartPar
The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution {\color{red}\bfseries{}{[}2{]}\_}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
New code should use the \sphinxtitleref{\textasciitilde{}numpy.random.Generator.normal}
method of a \sphinxtitleref{\textasciitilde{}numpy.random.Generator} instance instead;
please see the \DUrole{xref,std,std-ref}{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}


\subsection{Parameters}
\label{\detokenize{myfpga:id15}}\begin{description}
\sphinxlineitem{loc}{[}float or array\_like of floats{]}
\sphinxAtStartPar
Mean (“centre”) of the distribution.

\sphinxlineitem{scale}{[}float or array\_like of floats{]}
\sphinxAtStartPar
Standard deviation (spread or “width”) of the distribution. Must be
non\sphinxhyphen{}negative.

\sphinxlineitem{size}{[}int or tuple of ints, optional{]}
\sphinxAtStartPar
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}


\subsection{Returns}
\label{\detokenize{myfpga:id16}}\begin{description}
\sphinxlineitem{out}{[}ndarray or scalar{]}
\sphinxAtStartPar
Drawn samples from the parameterized normal distribution.

\end{description}


\subsection{See Also}
\label{\detokenize{myfpga:id17}}\begin{description}
\sphinxlineitem{scipy.stats.norm}{[}probability density function, distribution or{]}
\sphinxAtStartPar
cumulative density function, etc.

\end{description}

\sphinxAtStartPar
random.Generator.normal: which should be used for new code.


\subsection{Notes}
\label{\detokenize{myfpga:id18}}
\sphinxAtStartPar
The probability density for the Gaussian distribution is
\begin{equation*}
\begin{split}p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu\) is the mean and \(\sigma\) the standard
deviation. The square of the standard deviation, \(\sigma^2\),
is called the variance.

\sphinxAtStartPar
The function has its peak at the mean, and its “spread” increases with
the standard deviation (the function reaches 0.607 times its maximum at
\(x + \sigma\) and \(x - \sigma\) {\color{red}\bfseries{}{[}2{]}\_}).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.


\subsection{References}
\label{\detokenize{myfpga:id20}}

\subsection{Examples}
\label{\detokenize{myfpga:id23}}
\sphinxAtStartPar
Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} mean and standard deviation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Verify the mean and the variance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{mu} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.1  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\sphinxAtStartPar
Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
\PYG{g+gp}{... }               \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from the normal distribution with
mean 3 and standard deviation 2.5:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{numDerivative() (in module myfpga.sim\_lut)@\spxentry{numDerivative()}\spxextra{in module myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.numDerivative}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{numDerivative}}}{\sphinxparam{\DUrole{n}{func}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{eps}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}10}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{random() (in module myfpga.sim\_lut)@\spxentry{random()}\spxextra{in module myfpga.sim\_lut}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.sim_lut.random}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{myfpga.sim\_lut.}}\sphinxbfcode{\sphinxupquote{random}}}{\sphinxparam{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return random floats in the half\sphinxhyphen{}open interval {[}0.0, 1.0). Alias for
\sphinxtitleref{random\_sample} to ease forward\sphinxhyphen{}porting to the new random API.

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{myfpga:module-myfpga}}\label{\detokenize{myfpga:module-contents}}\index{module@\spxentry{module}!myfpga@\spxentry{myfpga}}\index{myfpga@\spxentry{myfpga}!module@\spxentry{module}}\index{FlipFlop (class in myfpga)@\spxentry{FlipFlop}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.FlipFlop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{FlipFlop}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_clock}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}FF.
\index{impl() (myfpga.FlipFlop method)@\spxentry{impl()}\spxextra{myfpga.FlipFlop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.FlipFlop.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje
Verilog necesario para implementar el FF inicializado.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut1 (class in myfpga)@\spxentry{Lut1}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut1}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{Lut1}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 1 entrada.
\index{impl() (myfpga.Lut1 method)@\spxentry{impl()}\spxextra{myfpga.Lut1 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut1.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje 
Verilog necesario para implementar la LUT inicializada.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut2 (class in myfpga)@\spxentry{Lut2}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{Lut2}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 2 entradas.
\index{impl() (myfpga.Lut2 method)@\spxentry{impl()}\spxextra{myfpga.Lut2 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut2.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje 
Verilog necesario para implementar la LUT inicializada.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut3 (class in myfpga)@\spxentry{Lut3}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut3}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{Lut3}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 3 entradas.
\index{impl() (myfpga.Lut3 method)@\spxentry{impl()}\spxextra{myfpga.Lut3 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut3.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje 
Verilog necesario para implementar la LUT inicializada.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut4 (class in myfpga)@\spxentry{Lut4}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut4}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{Lut4}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 4 entradas.
\index{impl() (myfpga.Lut4 method)@\spxentry{impl()}\spxextra{myfpga.Lut4 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut4.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje 
Verilog necesario para implementar la LUT inicializada.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut6 (class in myfpga)@\spxentry{Lut6}\spxextra{class in myfpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut6}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{myfpga.}}\sphinxbfcode{\sphinxupquote{Lut6}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 6 entradas.
\index{impl() (myfpga.Lut6 method)@\spxentry{impl()}\spxextra{myfpga.Lut6 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{myfpga:myfpga.Lut6.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje 
Verilog necesario para implementar la LUT inicializada.

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{myfpga}\sphinxstyleindexpageref{myfpga:\detokenize{module-myfpga}}
\item\relax\sphinxstyleindexentry{myfpga.fabric}\sphinxstyleindexpageref{myfpga:\detokenize{module-myfpga.fabric}}
\item\relax\sphinxstyleindexentry{myfpga.interfaz\_pcps}\sphinxstyleindexpageref{myfpga:\detokenize{module-myfpga.interfaz_pcps}}
\item\relax\sphinxstyleindexentry{myfpga.ring\_osc}\sphinxstyleindexpageref{myfpga:\detokenize{module-myfpga.ring_osc}}
\item\relax\sphinxstyleindexentry{myfpga.sim\_lut}\sphinxstyleindexpageref{myfpga:\detokenize{module-myfpga.sim_lut}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}