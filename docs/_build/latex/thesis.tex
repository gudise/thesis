%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{thesis}
\date{Jan 17, 2024}
\release{}
\author{gds}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{fpga package}
\label{\detokenize{fpga:module-fpga}}\label{\detokenize{fpga:fpga-package}}\label{\detokenize{fpga::doc}}\index{module@\spxentry{module}!fpga@\spxentry{fpga}}\index{fpga@\spxentry{fpga}!module@\spxentry{module}}\index{FlipFlop (class in fpga)@\spxentry{FlipFlop}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{FlipFlop}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_clock}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}FF.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia FF.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece el FF en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida del FF.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_clock}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que lleva la señal de reloj al FF.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada al FF.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restrición BEL que indica qué FF concreto es ocupado dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.FlipFlop attribute)@\spxentry{bel}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.FlipFlop method)@\spxentry{impl()}\spxextra{fpga.FlipFlop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar el FF inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación del FF inicializado, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{loc (fpga.FlipFlop attribute)@\spxentry{loc}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición del FF en la FPGA.

\end{fulllineitems}

\index{name (fpga.FlipFlop attribute)@\spxentry{name}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia FF.

\end{fulllineitems}

\index{w\_clock (fpga.FlipFlop attribute)@\spxentry{w\_clock}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.w_clock}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_clock}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de reloj.

\end{fulllineitems}

\index{w\_in (fpga.FlipFlop attribute)@\spxentry{w\_in}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de entrada.

\end{fulllineitems}

\index{w\_out (fpga.FlipFlop attribute)@\spxentry{w\_out}\spxextra{fpga.FlipFlop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.FlipFlop.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut1 (class in fpga)@\spxentry{Lut1}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{Lut1}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 1 entrada.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{init}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
\sphinxAtStartPar
Valor numérico que representa la función realizada por la LUT. La relación entrada/salida se asigna de la forma:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
I0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Out
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}1{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
donde init{[}i{]} es el i\sphinxhyphen{}ésimo bit del número ‘init’ en representación binaria LSB (i.e., init{[}0{]} es el bit menos significativo \sphinxhyphen{}“más a la izquierda”\sphinxhyphen{} de init).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece la LUT en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida de la LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada a la LUT. Se trata de una string con el nombre de la entrada correspondiente al pin I0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restricción BEL que indica qué LUT concreta es ocupada dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.Lut1 attribute)@\spxentry{bel}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.Lut1 method)@\spxentry{impl()}\spxextra{fpga.Lut1 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar la LUT inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación de la LUT inicializada, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{init (fpga.Lut1 attribute)@\spxentry{init}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.init}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{init}}}
\pysigstopsignatures
\sphinxAtStartPar
función realizada por la LUT.

\end{fulllineitems}

\index{loc (fpga.Lut1 attribute)@\spxentry{loc}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición de la LUT en la FPGA.

\end{fulllineitems}

\index{name (fpga.Lut1 attribute)@\spxentry{name}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia LUT.

\end{fulllineitems}

\index{pin (fpga.Lut1 attribute)@\spxentry{pin}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones de pines.

\end{fulllineitems}

\index{w\_in (fpga.Lut1 attribute)@\spxentry{w\_in}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de entrada.

\end{fulllineitems}

\index{w\_out (fpga.Lut1 attribute)@\spxentry{w\_out}\spxextra{fpga.Lut1 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut1.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut2 (class in fpga)@\spxentry{Lut2}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{Lut2}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 2 entradas.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{init}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
\sphinxAtStartPar
Valor numérico que representa la función realizada por la LUT. La relación entrada/salida se asigna de la forma:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
I1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Out
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}1{]}
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}2{]}
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}3{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
donde init{[}i{]} es el i\sphinxhyphen{}ésimo bit del número ‘init’ en representación binaria LSB (i.e., init{[}0{]} es el bit menos significativo \sphinxhyphen{}“más a la izquierda”\sphinxhyphen{} de init).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece la LUT en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida de la LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada a la LUT. Se trata de una string con el nombre de la entrada correspondiente al pin I0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restricción BEL que indica qué LUT concreta es ocupada dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.Lut2 attribute)@\spxentry{bel}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.Lut2 method)@\spxentry{impl()}\spxextra{fpga.Lut2 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar la LUT inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación de la LUT inicializada, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{init (fpga.Lut2 attribute)@\spxentry{init}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.init}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{init}}}
\pysigstopsignatures
\sphinxAtStartPar
función realizada por la LUT.

\end{fulllineitems}

\index{loc (fpga.Lut2 attribute)@\spxentry{loc}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición de la LUT en la FPGA.

\end{fulllineitems}

\index{name (fpga.Lut2 attribute)@\spxentry{name}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia LUT.

\end{fulllineitems}

\index{pin (fpga.Lut2 attribute)@\spxentry{pin}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones de pines.

\end{fulllineitems}

\index{w\_in (fpga.Lut2 attribute)@\spxentry{w\_in}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de señales de entrada.

\end{fulllineitems}

\index{w\_out (fpga.Lut2 attribute)@\spxentry{w\_out}\spxextra{fpga.Lut2 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut2.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut3 (class in fpga)@\spxentry{Lut3}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{Lut3}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 3 entradas.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{init}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
\sphinxAtStartPar
Valor numérico que representa la función realizada por la LUT. La relación entrada/salida se asigna de la forma:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
I2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Out
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}1{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}2{]}
\\
\sphinxhline
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}7{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
donde init{[}i{]} es el i\sphinxhyphen{}ésimo bit del número ‘init’ en representación binaria LSB (i.e., init{[}0{]} es el bit menos significativo \sphinxhyphen{}“más a la izquierda”\sphinxhyphen{} de init).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece la LUT en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida de la LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada a la LUT. Se trata de una string con el nombre de la entrada correspondiente al pin I0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restricción BEL que indica qué LUT concreta es ocupada dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.Lut3 attribute)@\spxentry{bel}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.Lut3 method)@\spxentry{impl()}\spxextra{fpga.Lut3 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar la LUT inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación de la LUT inicializada, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{init (fpga.Lut3 attribute)@\spxentry{init}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.init}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{init}}}
\pysigstopsignatures
\sphinxAtStartPar
función realizada por la LUT.

\end{fulllineitems}

\index{loc (fpga.Lut3 attribute)@\spxentry{loc}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición de la LUT en la FPGA.

\end{fulllineitems}

\index{name (fpga.Lut3 attribute)@\spxentry{name}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia LUT.

\end{fulllineitems}

\index{pin (fpga.Lut3 attribute)@\spxentry{pin}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones de pines.

\end{fulllineitems}

\index{w\_in (fpga.Lut3 attribute)@\spxentry{w\_in}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de señales de entrada.

\end{fulllineitems}

\index{w\_out (fpga.Lut3 attribute)@\spxentry{w\_out}\spxextra{fpga.Lut3 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut3.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut4 (class in fpga)@\spxentry{Lut4}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{Lut4}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 4 entradas.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{init}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
\sphinxAtStartPar
Valor numérico que representa la función realizada por la LUT. La relación entrada/salida se asigna de la forma:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
I3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Out
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}1{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}2{]}
\\
\sphinxhline
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}15{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
donde init{[}i{]} es el i\sphinxhyphen{}ésimo bit del número ‘init’ en representación binaria LSB (i.e., init{[}0{]} es el bit menos significativo \sphinxhyphen{}“más a la izquierda”\sphinxhyphen{} de init).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece la LUT en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida de la LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada a la LUT. Se trata de una string con el nombre de la entrada correspondiente al pin I0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restricción BEL que indica qué LUT concreta es ocupada dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.Lut4 attribute)@\spxentry{bel}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.Lut4 method)@\spxentry{impl()}\spxextra{fpga.Lut4 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar la LUT inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación de la LUT inicializada, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{init (fpga.Lut4 attribute)@\spxentry{init}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.init}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{init}}}
\pysigstopsignatures
\sphinxAtStartPar
función realizada por la LUT.

\end{fulllineitems}

\index{loc (fpga.Lut4 attribute)@\spxentry{loc}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición de la LUT en la FPGA.

\end{fulllineitems}

\index{name (fpga.Lut4 attribute)@\spxentry{name}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia LUT.

\end{fulllineitems}

\index{pin (fpga.Lut4 attribute)@\spxentry{pin}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones de pines.

\end{fulllineitems}

\index{w\_in (fpga.Lut4 attribute)@\spxentry{w\_in}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de señales de entrada.

\end{fulllineitems}

\index{w\_out (fpga.Lut4 attribute)@\spxentry{w\_out}\spxextra{fpga.Lut4 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut4.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}

\index{Lut6 (class in fpga)@\spxentry{Lut6}\spxextra{class in fpga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.}}\sphinxbfcode{\sphinxupquote{Lut6}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{init}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_out}}\sphinxparamcomma \sphinxparam{\DUrole{n}{w\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Modelo de FPGA\sphinxhyphen{}LUT de 6 entradas.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre de la instancia LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{init}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
\sphinxAtStartPar
Valor numérico que representa la función realizada por la LUT. La relación entrada/salida se asigna de la forma:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
I5
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I4
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
I0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Out
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}0{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}1{]}
\\
\sphinxhline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
init{[}2{]}
\\
\sphinxhline
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
.
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
init{[}63{]}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
donde init{[}i{]} es el i\sphinxhyphen{}ésimo bit del número ‘init’ en representación binaria LSB (i.e., init{[}0{]} es el bit menos significativo \sphinxhyphen{}“más a la izquierda”\sphinxhyphen{} de init).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Posición de la celda a la que pertenece la LUT en la FPGA. El formato de esta opción es un string formado por dos números enteros (coordenadas X, Y) separados por una coma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de salida de la LUT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{w\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del cable que contiene la señal de entrada a la LUT. Se trata de una string con el nombre de la entrada correspondiente al pin I0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}A\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}B\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}D\textquotesingle{}\}}}) \textendash{} Restricción BEL que indica qué LUT concreta es ocupada dentro de la celda.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Restricción de los pines lógicos (“I”) a los pines físicos (“A”) de la LUT. El formato es el mismo que el de la restricción LOCK\_PINS de XDC, i.e., un string de elementos ‘I\textless{}puerto lógico\textgreater{}:A\textless{}puerto físico\textgreater{}’ separados por comas, donde el puerto lógico es ‘I0’, y los puertos físicos varían de ‘A1’ a ‘A6’.

\end{itemize}

\end{description}\end{quote}
\index{bel (fpga.Lut6 attribute)@\spxentry{bel}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL.

\end{fulllineitems}

\index{impl() (fpga.Lut6 method)@\spxentry{impl()}\spxextra{fpga.Lut6 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.impl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{impl}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función devuelve un ‘string’ que contiene el código en lenguaje Verilog necesario para implementar la LUT inicializada.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Cadena que representa el código Verilog para la implementación de la LUT inicializada, con los parámetros actuales de la instancia.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{init (fpga.Lut6 attribute)@\spxentry{init}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.init}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{init}}}
\pysigstopsignatures
\sphinxAtStartPar
función realizada por la LUT.

\end{fulllineitems}

\index{loc (fpga.Lut6 attribute)@\spxentry{loc}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Posición de la LUT en la FPGA.

\end{fulllineitems}

\index{name (fpga.Lut6 attribute)@\spxentry{name}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre de la instancia LUT.

\end{fulllineitems}

\index{pin (fpga.Lut6 attribute)@\spxentry{pin}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones de pines.

\end{fulllineitems}

\index{w\_in (fpga.Lut6 attribute)@\spxentry{w\_in}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.w_in}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_in}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de señales de entrada.

\end{fulllineitems}

\index{w\_out (fpga.Lut6 attribute)@\spxentry{w\_out}\spxextra{fpga.Lut6 attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga:fpga.Lut6.w_out}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{w\_out}}}
\pysigstopsignatures
\sphinxAtStartPar
Señal de salida.

\end{fulllineitems}


\end{fulllineitems}



\section{Submodules}
\label{\detokenize{fpga:submodules}}
\sphinxstepscope


\subsection{fpga.fabric module}
\label{\detokenize{fpga.fabric:module-fpga.fabric}}\label{\detokenize{fpga.fabric:fpga-fabric-module}}\label{\detokenize{fpga.fabric::doc}}\index{module@\spxentry{module}!fpga.fabric@\spxentry{fpga.fabric}}\index{fpga.fabric@\spxentry{fpga.fabric}!module@\spxentry{module}}
\sphinxAtStartPar
Este módulo contiene una lista de algunos recursos relacionados con la
estructura interna de la FPGA; estas cantidades son invariantes (no se
modifican durante la ejecución de un programa).
\index{pynqz2 (in module fpga.fabric)@\spxentry{pynqz2}\spxextra{in module fpga.fabric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.fabric:fpga.fabric.pynqz2}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fpga.fabric.}}\sphinxbfcode{\sphinxupquote{pynqz2}}}
\pysigstopsignatures
\sphinxAtStartPar
Matriz de tamaño 114x150 cuya entrada i,j contiene los parámetros físicos de la celda SLICE\_X\{i\}Y\{j\} para la FPGA implementada sobre una placa de desarrollo \sphinxcode{\sphinxupquote{PYNQ\sphinxhyphen{}Z2}}. Si la celda no existe en esta FPGA se devuelve \sphinxtitleref{None}.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
lista de lista de str

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{fpga.interfaz\_pcps module}
\label{\detokenize{fpga.interfaz_pcps:module-fpga.interfaz_pcps}}\label{\detokenize{fpga.interfaz_pcps:fpga-interfaz-pcps-module}}\label{\detokenize{fpga.interfaz_pcps::doc}}\index{module@\spxentry{module}!fpga.interfaz\_pcps@\spxentry{fpga.interfaz\_pcps}}\index{fpga.interfaz\_pcps@\spxentry{fpga.interfaz\_pcps}!module@\spxentry{module}}\index{bitstr\_to\_bytestr() (in module fpga.interfaz\_pcps)@\spxentry{bitstr\_to\_bytestr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.bitstr_to_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bitstr\_to\_bytestr}}}{\sphinxparam{\DUrole{n}{bitstr\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Toma una lista de bits \sphinxtitleref{bitstr\_in} y la convierte a una lista de bytes del tamaño mínimo necesario para alojar \sphinxtitleref{bitstr\_width} bits.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstr\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de \{0}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1\}}}) \textendash{} Lista de bits.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstr\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de bits mínimos acomodados a la salida.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista de bytes.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de u8

\end{description}\end{quote}

\end{fulllineitems}

\index{bitstr\_to\_int() (in module fpga.interfaz\_pcps)@\spxentry{bitstr\_to\_int()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.bitstr_to_int}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bitstr\_to\_int}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Convierte una lista de bits en su correspondiente número decimal (entero).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entrada}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de \{0}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1\}}}) \textendash{} Representación binaria de un valor.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Representación decimal de \sphinxtitleref{entrada}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{bytestr\_to\_bitstr() (in module fpga.interfaz\_pcps)@\spxentry{bytestr\_to\_bitstr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.bytestr_to_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bytestr\_to\_bitstr}}}{\sphinxparam{\DUrole{n}{bytestr}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función toma una lista de bytes \sphinxtitleref{bytestr} y los aloja en una lista de bits de tamaño \sphinxtitleref{bitstr\_width}. Si \sphinxtitleref{bitstr\_width} es insuficiente, la lista de bits se truncará.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bytestr}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de u8}}) \textendash{} Lista de enteros entre 0 y 255 (bytes).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstr\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Tamaño de la lista de bits resultante.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista de bits.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de \{0,1\}

\end{description}\end{quote}

\end{fulllineitems}

\index{bytestr\_to\_int() (in module fpga.interfaz\_pcps)@\spxentry{bytestr\_to\_int()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.bytestr_to_int}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{bytestr\_to\_int}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Convierte una lista de bytes en su correspondiente número decimal (entero).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entrada}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de u8}}) \textendash{} Lista de \sphinxtitleref{int} entre 0 y 255 que representa un valor en base 256.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Valor entero (base 10) dado por la lista \sphinxtitleref{entrada}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{calc() (in module fpga.interfaz\_pcps)@\spxentry{calc()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.calc}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{calc}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion dispara un ciclo RDY\sphinxhyphen{}\textgreater{}CALC\sphinxhyphen{}\textgreater{}PRINT\sphinxhyphen{}\textgreater{}RDY en una máquina de estados finitos conectada a traves de \sphinxtitleref{serialport} y devuelve un bitstr de tamaño \sphinxtitleref{buffer\_out\_width}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{buffer\_out\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Tamaño del ‘bitstr’ devuelto.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Respuesta binaria devuelta por la máquina de estados finitos después de realizar el procesamiento en FPGA.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de \{0,1\}

\end{description}\end{quote}

\end{fulllineitems}

\index{int\_to\_bitstr() (in module fpga.interfaz\_pcps)@\spxentry{int\_to\_bitstr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.int_to_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{int\_to\_bitstr}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion convierte un numero \sphinxtitleref{entrada} en su representacion en base 2 (‘bitstr’, lista de 0/1). El número más a la dcha del bitstr (result{[}0{]}) es el menos significativo.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entrada}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Valor entero en base 10.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Representación binaria de \sphinxtitleref{entrada}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de \{0,1\}

\end{description}\end{quote}

\end{fulllineitems}

\index{int\_to\_bytestr() (in module fpga.interfaz\_pcps)@\spxentry{int\_to\_bytestr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.int_to_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{int\_to\_bytestr}}}{\sphinxparam{\DUrole{n}{entrada}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion convierte un numero \sphinxtitleref{entrada} en su representacion en base 256 (lista de u8 ‘bytestr’). El número más a la dcha del bytestr (result{[}0{]}) es el menos significativo.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entrada}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número a convertir en ‘bytestr’.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista que representa \sphinxtitleref{entrada} en base 256.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de u8

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_bitstr() (in module fpga.interfaz\_pcps)@\spxentry{print\_bitstr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.print_bitstr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{print\_bitstr}}}{\sphinxparam{\DUrole{n}{bitstr\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función imprime una lista de bits como una ‘string’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstr\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de \{0}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1\}}}) \textendash{} Lista de bits a imprimir.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_bytestr() (in module fpga.interfaz\_pcps)@\spxentry{print\_bytestr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.print_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{print\_bytestr}}}{\sphinxparam{\DUrole{n}{bytestr\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función imprime una lista de bytes como una ‘string’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bytestr\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de u8}}) \textendash{} Lista de bytes a imprimir.

\end{description}\end{quote}

\end{fulllineitems}

\index{receive\_bytestr() (in module fpga.interfaz\_pcps)@\spxentry{receive\_bytestr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.receive_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_bytestr}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bytestr\_size}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Recibe \sphinxtitleref{bytestr\_size} bytes a traves del puerto serie \sphinxtitleref{serialport}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bytestr\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de bytes a leer a través del puerto \sphinxtitleref{serialport}.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista de bytes leídos del puerto serie.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista de u8

\end{description}\end{quote}

\end{fulllineitems}

\index{receive\_u32() (in module fpga.interfaz\_pcps)@\spxentry{receive\_u32()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.receive_u32}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_u32}}}{\sphinxparam{\DUrole{n}{serialport}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion implementa un bucle para leer 4 bytes del puerto serie \sphinxtitleref{serialport}, y los devuelve en formato u32 (entero). Si no habia datos en el buffer de entrada a la hora de llamar a la funcion devuelve \sphinxhyphen{}1.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\sphinxlineitem{Returns}
\sphinxAtStartPar
En caso de éxito, entero leído de \sphinxtitleref{serialport}. En caso contrario, \sphinxhyphen{}1.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{receive\_u8() (in module fpga.interfaz\_pcps)@\spxentry{receive\_u8()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.receive_u8}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{receive\_u8}}}{\sphinxparam{\DUrole{n}{serialport}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion implementa un bucle para leer 1 byte del puerto serie \sphinxtitleref{serialport}, y devuelve dicho byte en formato u8 (un numero entre 0 y 255). Si no habia datos en el buffer de entrada a la hora de llamar a la funcion, devuelve \sphinxhyphen{}1.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\sphinxlineitem{Returns}
\sphinxAtStartPar
En caso de éxito, ‘byte’ leído del puerto serie en formato decimal. En otro caso, \sphinxhyphen{}1.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{resize\_array() (in module fpga.interfaz\_pcps)@\spxentry{resize\_array()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.resize_array}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{resize\_array}}}{\sphinxparam{\DUrole{n}{array\_old}}\sphinxparamcomma \sphinxparam{\DUrole{n}{array\_size}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion toma un \sphinxtitleref{array\_old} de tamaño arbitrario y transfiere los elementos a un array de tamaño \sphinxtitleref{array\_size}, empezando por el dígito menos significativo (a la dcha.). Si \sphinxtitleref{array\_size} no es suficiente para contener todo el \sphinxtitleref{array\_old}, la salida estará truncada. Si \sphinxtitleref{array\_size} es excesivo para contener \sphinxtitleref{array\_old}, los huecos que sobren se rellenan con 0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array\_old}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista}}) \textendash{} Array a redimensionar (tipo de datos arbitrario).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Tamaño del nuevo array.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista del mismo tipo que \sphinxtitleref{array\_old} redimensionada.

\sphinxlineitem{Return type}
\sphinxAtStartPar
lista

\end{description}\end{quote}

\end{fulllineitems}

\index{scan() (in module fpga.interfaz\_pcps)@\spxentry{scan()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.scan}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{scan}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bitstr\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_in\_width}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion dispara un ciclo RDY\sphinxhyphen{}\textgreater{}SCAN\sphinxhyphen{}\textgreater{}RDY en una máquina de estados finitos conectada a traves de \sphinxtitleref{serialport} y carga a la máquina un bitstr de tamaño \sphinxtitleref{buffer\_in\_width}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstr\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de \{0}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1\}}}) \textendash{} Lista de bits a cargar en la máquina de estados finitos, conteniendo datos de entrada necesarios para la operación de la FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{buffer\_in\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de bits escritos en la máquina de estados finitos.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_bytestr() (in module fpga.interfaz\_pcps)@\spxentry{send\_bytestr()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.send_bytestr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{send\_bytestr}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bytestr\_out}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Envía la lista de bytes \sphinxtitleref{bytestr\_out} a traves del puerto serie \sphinxtitleref{serialport}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bytestr\_out}} (\sphinxstyleliteralemphasis{\sphinxupquote{lista de u8}}) \textendash{} Lista de bytes (entero entre 0 y 255) a enviar a través del puerto serie.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
0

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_u8() (in module fpga.interfaz\_pcps)@\spxentry{send\_u8()}\spxextra{in module fpga.interfaz\_pcps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.interfaz_pcps:fpga.interfaz_pcps.send_u8}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.interfaz\_pcps.}}\sphinxbfcode{\sphinxupquote{send\_u8}}}{\sphinxparam{\DUrole{n}{serialport}}\sphinxparamcomma \sphinxparam{\DUrole{n}{number}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta funcion envia un numero en formato u8 a traves de \sphinxtitleref{serialport}. Si \sphinxtitleref{number} es mayor que 256, se enviará el resto: number\%256.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{serialport}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyserial.Serial}}) \textendash{} Objeto \sphinxtitleref{Serial} del paquete ‘pyserial’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{number}} (\sphinxstyleliteralemphasis{\sphinxupquote{u8}}) \textendash{} Byte (entero entre 0 y 255) a enviar a través del puerto serie.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
0

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{fpga.ring\_osc module}
\label{\detokenize{fpga.ring_osc:module-fpga.ring_osc}}\label{\detokenize{fpga.ring_osc:fpga-ring-osc-module}}\label{\detokenize{fpga.ring_osc::doc}}\index{module@\spxentry{module}!fpga.ring\_osc@\spxentry{fpga.ring\_osc}}\index{fpga.ring\_osc@\spxentry{fpga.ring\_osc}!module@\spxentry{module}}
\sphinxAtStartPar
Este módulo contiene una serie de clases y funciones para implementar y
medir una matriz de osciladores de anillo en FPGA, tanto estándar como
de Galois.
\index{Dominio (class in fpga.ring\_osc)@\spxentry{Dominio}\spxextra{class in fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{Dominio}}}{\sphinxparam{\DUrole{n}{N\_osc}\DUrole{o}{=}\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x1}\DUrole{o}{=}\DUrole{default_value}{inf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dx}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y0}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y1}\DUrole{o}{=}\DUrole{default_value}{inf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dy}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{directriz}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}y\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Este objeto contiene las localizaciones de un conjunto de osciladores dispuestos atendiendo a diversos parámetros geométricos. Si directriz=y, estos se colocan formando una matriz rectangular, la cual crece en dirección y en incrementos de dy. Cuando se alcanza el límite y1, la matriz se incrementa una cantidad dx en la dirección x, y vuelve a la coordenada y0. Si directriz=x, el comentario anterior se aplica substituyendo x \textless{}\sphinxhyphen{}\textgreater{} y.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_osc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de osciladores del dominio.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Coordenada X del primer oscilador de la matriz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Coordenada X máxima de la matriz (no se sobrepasará).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Incremento de la coordenada X. Notar que habitualmente en las FPGA de Xilinx se reservan las coordenadas X par/impar para distintos tipos de celda (‘0’ y ‘1’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y0}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Coordenada Y del primer oscilador de la matriz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Coordenada Y máxima de la matriz (no se sobrepasará).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dy}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Incremento de la coordenada Y.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directriz}} (\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Dirección de crecimiento de la matriz (hasta llegar a la coordenada
máxima). Puede ser ‘y’ o ‘x’.

\end{itemize}

\end{description}\end{quote}
\index{N\_osc (fpga.ring\_osc.Dominio attribute)@\spxentry{N\_osc}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.N_osc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_osc}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de osciladores del anillo.

\end{fulllineitems}

\index{directriz (fpga.ring\_osc.Dominio attribute)@\spxentry{directriz}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.directriz}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{directriz}}}
\pysigstopsignatures
\sphinxAtStartPar
Dirección de crecimiento de la matriz de anillos.

\end{fulllineitems}

\index{dx (fpga.ring\_osc.Dominio attribute)@\spxentry{dx}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.dx}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{dx}}}
\pysigstopsignatures
\sphinxAtStartPar
Incremento de la coordenada ‘X’.

\end{fulllineitems}

\index{dy (fpga.ring\_osc.Dominio attribute)@\spxentry{dy}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.dy}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{dy}}}
\pysigstopsignatures
\sphinxAtStartPar
Incremento de la coordenada ‘Y’.

\end{fulllineitems}

\index{help() (fpga.ring\_osc.Dominio method)@\spxentry{help()}\spxextra{fpga.ring\_osc.Dominio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘Dominio’.

\end{fulllineitems}

\index{osc\_coord (fpga.ring\_osc.Dominio attribute)@\spxentry{osc\_coord}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.osc_coord}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{osc\_coord}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de las coordenadas de los anillos, dados en forma de par x,y.

\end{fulllineitems}

\index{x0 (fpga.ring\_osc.Dominio attribute)@\spxentry{x0}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.x0}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{x0}}}
\pysigstopsignatures
\sphinxAtStartPar
Coordenada ‘X’ inicial.

\end{fulllineitems}

\index{x1 (fpga.ring\_osc.Dominio attribute)@\spxentry{x1}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.x1}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{x1}}}
\pysigstopsignatures
\sphinxAtStartPar
Coordenada ‘X’ final.

\end{fulllineitems}

\index{y0 (fpga.ring\_osc.Dominio attribute)@\spxentry{y0}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.y0}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{y0}}}
\pysigstopsignatures
\sphinxAtStartPar
Coordenada ‘Y’ inicial.

\end{fulllineitems}

\index{y1 (fpga.ring\_osc.Dominio attribute)@\spxentry{y1}\spxextra{fpga.ring\_osc.Dominio attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio.y1}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{y1}}}
\pysigstopsignatures
\sphinxAtStartPar
Coordenada ‘Y’ final.

\end{fulllineitems}


\end{fulllineitems}

\index{GaloisMatrix (class in fpga.ring\_osc)@\spxentry{GaloisMatrix}\spxextra{class in fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{GaloisMatrix}}}{\sphinxparam{\DUrole{n}{N\_inv=3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dominios=\textless{}fpga.ring\_osc.Dominio object\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl=False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{trng=0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly=\sphinxhyphen{}1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{inverted\_end=True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Objeto que contiene una matriz de osciladores de anillo de Galois.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de inversores de cada oscilador.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dominios}} ({\hyperref[\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Dominio}}}}} | list(\sphinxtitleref{Dominio}), opcional) \textendash{} Osciladores que forman la matriz. Se construye como una lista de objetos ‘Dominio’. Si solo pasamos un dominio de osciladores podemos pasar un objeto ‘Dominio’, en lugar de una lista.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Dado que todos los anillos de la matriz son idénticos por diseño, esta opción es la misma que la aplicada para un solo oscilador (ver ‘bel’ en ‘GaloisRing’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Dado que todos los anillos de la matriz son idénticos por diseño, esta opción es la misma que la aplicada para un solo oscilador (ver ‘pin’ en ‘GaloisRing’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si ‘True’ se utilizan modelos LUT6 para los inversores, permitiendo utilizar 5 puertos para configurar el anillo mediante PDL. Si ‘False’ se utilizan modelos LUT1 para los inversores y LUT2 para el enable AND.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{trng}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta variable modifica de manera profunda el diseño de la matriz GARO implementada. Si se incluye este parámetro como un entero mayor que cero, el diseño genera un arreglo de bits generados por cada GARO como TRNG. En este caso, el buffer de salida del diseño tiene un tamaño ‘trng’ dado por esta variable. Alternativamente, si no se incluye esta opción (o vale ‘0’), el diseño incluye un medidor de sesgo que devuelve el valor del sesgo de cada GARO, en lugar de producir un arreglo de bits.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta variable determina el polinomio a implementar en hardware. Si su valor es negativo (por defecto), entonces se implementa un anillo de Galois genérico configurable en tiempo de ejecución. En caso contrario, se producirá un anillo que implementa un polinomio fijo, utilizando la misma codificación que la función ‘,edir()’. Esto puede ahorrar una cierta cantidad de recursos hardware, a costa de perder flexibilidad.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inverted\_end}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si esta opción es ‘True’, se añadirá un inversor al final del anillo, lo cual según parece evita acoplos entre anillos cercanos. Notar que la presencia o no de este inversor cambia el número de elementos a efectos de las opciones ‘bel’ y ‘pin’.

\end{itemize}

\end{description}\end{quote}
\index{gen\_garomatrix() (fpga.ring\_osc.GaloisMatrix method)@\spxentry{gen\_garomatrix()}\spxextra{fpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix.gen_garomatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_garomatrix}}}{\sphinxparam{\DUrole{n}{out\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}garomatrix.v\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Genera un diseño ‘out\_name’ en formato Verilog con la implementación de los dominios introducidos durante la inicialización del objeto. El principal uso de esta función es dentro de la función ‘implement()’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nombre del fichero de salida.

\end{description}\end{quote}

\end{fulllineitems}

\index{help() (fpga.ring\_osc.GaloisMatrix method)@\spxentry{help()}\spxextra{fpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘GaloisMatrix’.

\end{fulllineitems}

\index{implement() (fpga.ring\_osc.GaloisMatrix method)@\spxentry{implement()}\spxextra{fpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix.implement}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{implement}}}{\sphinxparam{\DUrole{n}{projname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}project\_garomatrix\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{projdir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{njobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{files}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{board}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pynqz2\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qspi}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{routing}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pblock}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}\DUrole{o}{=}\DUrole{default_value}{32}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Copia en el directorio ‘self.projdir’ todos los archivos necesarios para implementar una matriz de osciladores de anillo de Galois con medición del sesgo (“bias”) y comunicación pc \textless{}\sphinxhyphen{}\textgreater{} microprocesador \textless{}\sphinxhyphen{}\textgreater{} FPGA.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{projname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nombre del proyecto de Vivado.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{projdir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Directorio donde se creará el proyecto de Vivado y las fuentes (por defecto el directorio de trabajo actual).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{njobs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de núcleos que utiilizará Vivado paralelamente para la síntesis/implementación.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, se implementará una matriz de divisores de reloj de frecuencia conocida, lo que permite depurar el diseño al conocer qué resultados deben salir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{files}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, pinta los archivos necesarios para implementar la matriz en FPGA. Esta opción se puede desactivar (False) cuando queremos configurar un objeto tipo ‘Romatrix’ pero no vamos a implementarla físicamente (por ejemplo porque ya lo hemos hecho y solo queremos medir, o vamos a simularla sin realizarla).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{board}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Placa de desarrollo utilizada en el proyecyo. Las opciones soportadas son: ‘pynqz2’, ‘zybo’, ‘cmoda7\_15t’ o ‘cmoda7\_35t’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qspi}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, el flujo de diseño incluirá el guardado del bitstream en la memoria flash de la placa para que se auto\sphinxhyphen{}programe al encenderse.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{routing}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, el flujo de diseño incluirá el cableado de los inversores después de la síntesis. Esto aumenta las probabilidades de que la herramienta haga un cableado idéntico, pero es recomendable comprobarlo. (NOTA: no tengo garantías de que esta opción sea del todo compatible con \sphinxhyphen{}qspi).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pblock}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si esta opción es ‘True’ se inserta la matriz en un pblock tal que el espacio dentro del bloque se excluye para toda lógica que no sea la propia matriz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción especifica la anchura del canal de datos PS\textless{}\textendash{}\textgreater{}PL.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{buffer\_out\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción especifica la anchura de la palabra de respuesta (i.e., de la medida).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{medir() (fpga.ring\_osc.GaloisMatrix method)@\spxentry{medir()}\spxextra{fpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix.medir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{medir}}}{\sphinxparam{\DUrole{n}{puerto}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}/dev/ttyS1\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{osc}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{resol}\DUrole{o}{=}\DUrole{default_value}{14}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fdiv}\DUrole{o}{=}\DUrole{default_value}{9}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bias}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{log}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baudrate}\DUrole{o}{=}\DUrole{default_value}{9600}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función mide la frecuencia de una matriz de osciladores de Galois ‘GaloisMatrix’, una vez esta ha sido implementado en FPGA. El resultado se devuelve como un objeto ‘Tensor’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{puerto}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Esta opción especifica el puerto serie al que se conecta la
FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{osc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Lista de osciladores a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Lista de PDL a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_rep}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de repeticiones a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{resol}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} log\_2 del número de ciclos de referencia a completar para dar por terminada la medida (por defecto 14, i.e., 2\textasciicircum{}14 = 16384 ciclos).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Esta variable indica el índice del polinomio a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fdiv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} log\_2 del factor de división menos uno, para el reloj de muestreo (por defecto 9, i.e., 2\textasciicircum{}(9+1)=1024; cin f\_ref=100 MHz esto supone una frecuencia de muestre f\_s=97.65 kHz).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bias}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Si se pasa esta opción como “True” el resultado se dará en tanto por 1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{log}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Si se pasa “True” se escriben algunos datos a modo de log.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Si se pasa “True” se pinta una barra de progreso de la medida. Desactivar esta opción (“False”) hace más cómodo utilizar esta función en un bucle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{baudrate}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Tasa de transferencia del protocolo serie UART PC\textless{}\textendash{}\textgreater{}PS. Debe concordar con el programa compilador en PS.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (fpga.ring\_osc.GaloisMatrix method)@\spxentry{save()}\spxextra{fpga.ring\_osc.GaloisMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisMatrix.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para guardar objetos serializados con el módulo ‘pickle’.

\end{fulllineitems}


\end{fulllineitems}

\index{GaloisRing (class in fpga.ring\_osc)@\spxentry{GaloisRing}\spxextra{class in fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{GaloisRing}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{poly}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{inverted\_end}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Lista de elementos (LUT) que constituyen un oscilador de anillo de Galois junto con la información necesaria para su implementación en FPGA utilzando el software ‘Vivado’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre utilizado para identificar el anillo.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de inversores que forman el anillo.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Parámetro ‘loc’ de la primera LUT del anillo (ver clase ‘Lut’). Solo se da la posición de la primera LUT porque los anillos siempre se construyen ocupando todos los ‘bel’ de una celda antes de pasar a la celda inmediatamente superior (de modo que, dadas las coordenadas del primer elemento, las demás están predeterminadas). La “celda inmediatamente superior” es X+1 si X es par, Y+1 si X es impar.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{char o lista de char}}) \textendash{} Lista de parámetros ‘bel’ para cada elemento del anillo (ver clase ‘Lut’). Cada elemento de la lista se aplica en orden correlativo al elemento del anillo (la primera restricción se aplica al primer elemento, la segunda al segundo, etc). Pueden darse menos restricciones que inversores forman el anillo, pero entonces quedarán LUT sin fijar. Notar además que el valor de esta restricción es excluyente entre LUT que forman parte de la misma celda: cada celda tiene cuatro posibles posiciones A, B, C y D, y dos LUT no pueden ocupar el mismo espacio. Esta función no avisa de esta violación: el usuario es responsable de que los valores ‘bel’ introducidos sean todos distintos entre sí en grupos de cuatro. En otro caso, el diseño fallará. Además de una lista de caracteres, esta opción admite un único caracter, pero entonces solo se restringirá la primera LUT. Notar que el último elemento en un anillo ‘GaloisRing’ siempre será un flip\sphinxhyphen{}flop, y el penúltimo elemento depende de la opción ‘inverted\_end’: si ‘True’, el número de  elementos total del anillo será igual a N\_inv+2, siendo el penúltimo elemento siempre una LUT1 (inversor final). Si por el contrario esta opción es ‘False’ entonces el número de elementos del anillo será N\_inv+1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str o lista de str}}) \textendash{} Lista de parámetros ‘pin’ de cada LUT que forma parte del anillo (ver clase ‘Lut’). Cada elemento de la lista se aplica en orden correlativo al elemento del anillo (la primera restricción se aplica al primer elemento, la segunda al segundo, etc). Pueden darse menos restricciones que inversores forman el anillo, pero entonces quedarán LUT sin mapear. Notar que el mapeo debe ser coherente con el tipo de LUT que se está fijando, y en particular los inversores inicial y final siempre son de tipo LUT1 (i.e., solo se puede fijar el pin ‘I0’). Notar que, dado que el último elemento (N\_inv+2 o N\_inv+1, dependiendo de la opción ‘inverted\_end’) de un anillo ‘GaloisRing’ es un flip\sphinxhyphen{}flop, a efectos de la opción “pin” este se ignora (esta opción restringe solo los pines de las LUT, no del flip\sphinxhyphen{}flop). Por definición, el puerto lógico ‘I0’ siempre es el que recoge la señal del elemento precedente en el bucle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si ‘True’ se utilizan modelos LUT6 para los inversores, permitiendo utilizar 5 puertos para configurar el anillo mediante PDL. Si ‘False’ se utilizan modelos LUT1 para los inversores y LUT2 para el enable AND.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta variable determina el polinomio a implementar en hardware. Si su valor es negativo (por defecto), entonces se implementa un anillo de Galois genérico configurable en tiempo de ejecución. En caso contrario, se producirá un anillo que implementa un polinomio fijo, utilizando la misma codificación que la función ‘,edir()’. Esto puede ahorrar una cierta cantidad de recursos hardware, a costa de perder flexibilidad.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inverted\_end}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si esta opción es ‘True’, se añadirá un inversor al final del anillo, lo cual según parece evita acoplos entre anillos cercanos. Notar que la presencia o no de este inversor cambia el número de elementos a efectos de las opciones ‘bel’ y ‘pin’.

\end{itemize}

\end{description}\end{quote}
\index{N\_inv (fpga.ring\_osc.GaloisRing attribute)@\spxentry{N\_inv}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.N_inv}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_inv}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de inversores del anillo.

\end{fulllineitems}

\index{bel (fpga.ring\_osc.GaloisRing attribute)@\spxentry{bel}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de restricciones BEL para cada elemento del anillo.Lista de restricciones BEL para cada elemento del anillo.

\end{fulllineitems}

\index{elements (fpga.ring\_osc.GaloisRing attribute)@\spxentry{elements}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.elements}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{elements}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de objetos que conforman el anillo. Esta consisitirá en N\_inv objetos ‘Lut’, más un inversor en caso de que la opción {\color{red}\bfseries{}\textasciigrave{}}inverted\_end\textasciigrave{}=True, más un flip\sphinxhyphen{}flop ‘FF’.

\end{fulllineitems}

\index{help() (fpga.ring\_osc.GaloisRing method)@\spxentry{help()}\spxextra{fpga.ring\_osc.GaloisRing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘GaloisRing’.

\end{fulllineitems}

\index{loc (fpga.ring\_osc.GaloisRing attribute)@\spxentry{loc}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Parámetro LOC de la primera puerta del anillo.

\end{fulllineitems}

\index{name (fpga.ring\_osc.GaloisRing attribute)@\spxentry{name}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre del anillo instanciado.

\end{fulllineitems}

\index{pin (fpga.ring\_osc.GaloisRing attribute)@\spxentry{pin}\spxextra{fpga.ring\_osc.GaloisRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.GaloisRing.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de restricciones PIN para cada elemento del anillo.Lista de restricciones PIN para cada elemento del anillo.

\end{fulllineitems}


\end{fulllineitems}

\index{StdMatrix (class in fpga.ring\_osc)@\spxentry{StdMatrix}\spxextra{class in fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{StdMatrix}}}{\sphinxparam{\DUrole{n}{N\_inv=3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dominios=\textless{}fpga.ring\_osc.Dominio object\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin=\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl=False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Objeto que contiene una matriz de osciladores de anillo estándar.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de inversores de cada oscilador.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dominios}} ({\hyperref[\detokenize{fpga.ring_osc:fpga.ring_osc.Dominio}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Dominio}}}}} o lista de \sphinxtitleref{Dominio}) \textendash{} Osciladores que forman la matriz. Se construye como una lista de objetos \sphinxtitleref{Dominio}. Si solo pasamos un dominio de osciladores podemos pasar un objeto \sphinxtitleref{Dominio}, en lugar de una lista.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Dado que todos los anillos de la matriz son idénticos por diseño, esta opción es la misma que la aplicada para un solo oscilador (ver \sphinxtitleref{bel} en {\hyperref[\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StdRing}}}}}).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Dado que todos los anillos de la matriz son idénticos por diseño, esta opción es la misma que la aplicada para un solo oscilador (ver ‘pin’ en ‘StdRing’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si \sphinxtitleref{True} se utilizan modelos LUT6 para los inversores, permitiendo utilizar 5 puertos para configurar el anillo mediante PDL. Si \sphinxtitleref{False} se utilizan modelos :obj:Lut1 para los inversores y :obj:Lut2 para el enable AND.

\end{itemize}

\end{description}\end{quote}
\index{N\_bits\_osc (fpga.ring\_osc.StdMatrix attribute)@\spxentry{N\_bits\_osc}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.N_bits_osc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_bits\_osc}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de bits necesarios para especificar cada oscilador.

\end{fulllineitems}

\index{N\_bits\_pdl (fpga.ring\_osc.StdMatrix attribute)@\spxentry{N\_bits\_pdl}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.N_bits_pdl}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_bits\_pdl}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de bits necesarios para especificar cada PDL.

\end{fulllineitems}

\index{N\_bits\_resol (fpga.ring\_osc.StdMatrix attribute)@\spxentry{N\_bits\_resol}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.N_bits_resol}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_bits\_resol}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de bits necesarios para especificar la resolución del proceso de medida.

\end{fulllineitems}

\index{N\_inv (fpga.ring\_osc.StdMatrix attribute)@\spxentry{N\_inv}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.N_inv}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_inv}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de inversores de cada anillo de la matriz.

\end{fulllineitems}

\index{N\_osc (fpga.ring\_osc.StdMatrix attribute)@\spxentry{N\_osc}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.N_osc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_osc}}}
\pysigstopsignatures
\sphinxAtStartPar
Número total de osciladores de la matriz.

\end{fulllineitems}

\index{bel (fpga.ring\_osc.StdMatrix attribute)@\spxentry{bel}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones BEL de cada anillo.

\end{fulllineitems}

\index{dominios (fpga.ring\_osc.StdMatrix attribute)@\spxentry{dominios}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.dominios}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{dominios}}}
\pysigstopsignatures
\sphinxAtStartPar
Dominio de que consta la matriz.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
Lista de

\sphinxlineitem{Type}
\sphinxAtStartPar
obj

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_romatrix() (fpga.ring\_osc.StdMatrix method)@\spxentry{gen\_romatrix()}\spxextra{fpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.gen_romatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_romatrix}}}{\sphinxparam{\DUrole{n}{out\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}romatrix.v\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Genera un diseño ‘out\_name’ en formato Verilog con la implementación de
los dominios introducidos durante la inicialización del objeto. El
principal uso de esta función es dentro de la función ‘implement()’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nombre del fichero de salida.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Flag que indica si se debe geenrar un diseño de depuración en lugar de una verdadera matriz de osciladores de anillo. En el diseño de depuración se substituye cada anillo por un divisor de reloj de frecuencia conocida, lo que permite depurar la interfaz de medida.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{help() (fpga.ring\_osc.StdMatrix method)@\spxentry{help()}\spxextra{fpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘StdMatrix’.

\end{fulllineitems}

\index{implement() (fpga.ring\_osc.StdMatrix method)@\spxentry{implement()}\spxextra{fpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.implement}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{implement}}}{\sphinxparam{\DUrole{n}{projname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}project\_romatrix\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{projdir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{njobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{files}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{board}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pynqz2\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qspi}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{routing}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pblock}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{buffer\_out\_width}\DUrole{o}{=}\DUrole{default_value}{32}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_clock}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Copia en el directorio ‘self.projdir’ todos los archivos necesarios para implementar una matriz de osciladores de anillo con medición de la frecuencia y comunicación pc \textless{}\sphinxhyphen{}\textgreater{} microprocesador \textless{}\sphinxhyphen{}\textgreater{} FPGA.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{projname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nombre del proyecto de Vivado.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{projdir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Directorio donde se creará el proyecto de Vivado y las fuentes (por defecto el directorio de trabajo actual).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{njobs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de núcleos que utiilizará Vivado paralelamente para la síntesis/implementación.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si ‘True’, se implementará una matriz de divisores de reloj de frecuencia conocida, lo que permite depurar el diseño al conocer qué resultados deben salir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{files}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si ‘True’, pinta los archivos necesarios para implementar la matriz en FPGA. Esta opción se puede desactivar (False) cuando queremos configurar un objeto tipo ‘Romatrix’ pero no vamos a implementarla físicamente (por ejemplo porque ya lo hemos hecho y solo queremos medir, o vamos a simularla sin realizarla).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{board}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Placa de desarrollo utilizada en el proyecyo. Las opciones soportadas son: ‘pynqz2’, ‘zybo’, ‘cmoda7\_15t’ o ‘cmoda7\_35t’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qspi}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, el flujo de diseño incluirá el guardado del bitstream en la memoria flash de la placa para que se auto\sphinxhyphen{}programe al encenderse.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{routing}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si “True”, el flujo de diseño incluirá el cableado de los inversores después de la síntesis. Esto aumenta las probabilidades de que la herramienta haga un cableado idéntico, pero es recomendable comprobarlo. (NOTA: no tengo garantías de que esta opción sea del todo compatible con \sphinxhyphen{}qspi).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pblock}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si esta opción es ‘True’ se inserta la matriz en un pblock tal que el espacio dentro del bloque se excluye para toda lógica que no sea la propia matriz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción especifica la anchura del canal de datos PS\textless{}\textendash{}\textgreater{}PL.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{buffer\_out\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción especifica la anchura de la palabra de respuesta (i.e., de la medida).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f\_clock}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Frecuencia del reloj del diseño (en MHz).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{medir() (fpga.ring\_osc.StdMatrix method)@\spxentry{medir()}\spxextra{fpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.medir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{medir}}}{\sphinxparam{\DUrole{n}{puerto}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}/dev/ttyS1\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{osc}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{resol}\DUrole{o}{=}\DUrole{default_value}{17}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_ref}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{log}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{baudrate}\DUrole{o}{=}\DUrole{default_value}{9600}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función mide la frecuencia de una matriz de osciladores estándar ‘StdMatrix’, una vez esta ha sido implementado en FPGA. El resultado se devuelve como un objeto ‘Tensor’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{puerto}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción especifica el puerto serie al que se conecta la FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{osc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Lista de osciladores a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Lista de PDL a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_rep}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de repeticiones a medir.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{resol}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} log\_2 del número de ciclos de referencia a completar para dar por terminada la medida (por defecto 17, i.e., 2\textasciicircum{}17 = 131072 ciclos).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{float}} (\sphinxstyleliteralemphasis{\sphinxupquote{f\_ref =}}) \textendash{} Frecuencia del reloj de referencia. Si se proporciona este valor, el resultado obtenido se devuelve en las mismas unidades en que se haya pasado este valor “f\_ref”.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opcional}} \textendash{} Frecuencia del reloj de referencia. Si se proporciona este valor, el resultado obtenido se devuelve en las mismas unidades en que se haya pasado este valor “f\_ref”.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{log}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si se pasa “True” se escriben algunos datos a modo de log.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si se pasa “True” se pinta una barra de progreso de la medida. Desactivar esta opción (“False”) hace más cómodo utilizar esta función en un bucle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{baudrate}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Tasa de transferencia del protocolo serie UART PC\textless{}\textendash{}\textgreater{}PS. Debe concordar con el programa compilador en PS.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{osc\_list (fpga.ring\_osc.StdMatrix attribute)@\spxentry{osc\_list}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.osc_list}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{osc\_list}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista completa de osciladores que componen la matriz.

\end{fulllineitems}

\index{pdl (fpga.ring\_osc.StdMatrix attribute)@\spxentry{pdl}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.pdl}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pdl}}}
\pysigstopsignatures
\sphinxAtStartPar
Valor booleano que indica si los anillos de la matriz son configurables mediante PDL.

\end{fulllineitems}

\index{pin (fpga.ring\_osc.StdMatrix attribute)@\spxentry{pin}\spxextra{fpga.ring\_osc.StdMatrix attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Restricciones PIN de cada anillo.

\end{fulllineitems}

\index{save() (fpga.ring\_osc.StdMatrix method)@\spxentry{save()}\spxextra{fpga.ring\_osc.StdMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdMatrix.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para guardar objetos serializados con el módulo ‘pickle’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del archivo de salida.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StdRing (class in fpga.ring\_osc)@\spxentry{StdRing}\spxextra{class in fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{StdRing}}}{\sphinxparam{\DUrole{n}{name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pin}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pdl}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Este objeto contiene una lista de elementos (LUT) que constituyen un oscilador de anillo estándar junto con la información necesaria para su implementación en FPGA utilzando el software ‘Vivado’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre utilizado para identificar el anillo.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de inversores que forman el anillo.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Parámetro ‘loc’ de la primera LUT del anillo (ver clase ‘Lut’). En un anillo estándar esta LUT siempre corresponde a la puerta AND inicial. Solo se da la posición de la primera LUT porque los anillos siempre se construyen ocupando todos los ‘bel’ de una celda antes de pasar a la celda inmediatamente superior (de modo que, dadas las coordenadas del primer elemento, las demás están predeterminadas). La “celda inmediatamente superior” es X+1 si X es par, Y+1 si X es impar.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bel}} (\sphinxstyleliteralemphasis{\sphinxupquote{char o lista de char}}) \textendash{} Lista de parámetros ‘bel’ para cada LUT del anillo (ver clase ‘Lut’). Cada elemento de la lista se aplica en orden correlativo al elemento del anillo (la primera restricción se aplica al AND inicial, la segunda al primer inversor, etc). Pueden darse menos restricciones que inversores forman el anillo, pero entonces quedarán LUT sin fijar. Notar además que el valor de esta restricción es excluyente entre LUT que forman parte de la misma celda: cada celda tiene cuatro posibles posiciones A, B, C y D, y dos LUT no pueden ocupar el mismo espacio. Esta función no avisa de esta violación: el usuario es responsable de que los valores ‘bel’ introducidos sean todos distintos entre sí en grupos de cuatro. En otro caso, el diseño fallará. Además de una lista de caracteres, esta opción admite un único caracter, pero entonces solo se restringirá la AND inicial. Ver opción ‘bel’ de la clase ‘Lut’. Notar que el número de elementos total de un anillo “StdRing” es igual a N\_inv+1, siendo el primero siempre una LUT2 (AND).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{str o lista de str}}) \textendash{} Lista de parámetros ‘pin’ de cada LUT que forma parte del anillo (ver clase ‘Lut’). Cada elemento de la lista se aplica en orden correlativo al elemento del anillo (la primera restricción se aplica al AND inicial, la segunda al primer inversor, etc). Pueden darse menos restricciones que inversores forman el anillo, pero entonces quedarán LUT sin mapear. Notar que el mapeo debe ser coherente con el tipo de LUT que se está fijando, y en particular el AND inicial siempre es de tipo LUT2 (i.e., solo se pueden fijar los pines ‘I0’ y ‘I1’). Notar que el número de elementos total de un anillo “StdRing” es igual a N\_inv+1, siendo el primero siempre una LUT2 (AND). Por definición, el puerto lógico ‘I0’ siempre es el que recoge la señal del elemento precedente en el bucle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Si ‘True’ se utilizan modelos LUT6 para los inversores, permitiendo utilizar 5 puertos para configurar el anillo mediante PDL. Si ‘False’ se utilizan modelos LUT1 para los inversores y LUT2 para el enable AND. Por defecto False.

\end{itemize}

\end{description}\end{quote}
\index{N\_inv (fpga.ring\_osc.StdRing attribute)@\spxentry{N\_inv}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.N_inv}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{N\_inv}}}
\pysigstopsignatures
\sphinxAtStartPar
Número de inversores del anillo.

\end{fulllineitems}

\index{bel (fpga.ring\_osc.StdRing attribute)@\spxentry{bel}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.bel}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{bel}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de restricciones BEL para cada elemento del anillo.

\end{fulllineitems}

\index{elements (fpga.ring\_osc.StdRing attribute)@\spxentry{elements}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.elements}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{elements}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de objetos Lut que conforman el anillo. El primer elemento será Lut2, y los restantes \sphinxtitleref{N\_inv} elementos serán Lut1 o Lut6 en función de si la opción \sphinxtitleref{pdl} es ‘True’.

\end{fulllineitems}

\index{help() (fpga.ring\_osc.StdRing method)@\spxentry{help()}\spxextra{fpga.ring\_osc.StdRing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.help}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{help}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Ayuda de la clase ‘StdRing’.

\end{fulllineitems}

\index{loc (fpga.ring\_osc.StdRing attribute)@\spxentry{loc}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.loc}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{loc}}}
\pysigstopsignatures
\sphinxAtStartPar
Parámetro LOC de la primera puerta del anillo.

\end{fulllineitems}

\index{name (fpga.ring\_osc.StdRing attribute)@\spxentry{name}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.name}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombre del anillo instanciado.

\end{fulllineitems}

\index{pin (fpga.ring\_osc.StdRing attribute)@\spxentry{pin}\spxextra{fpga.ring\_osc.StdRing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.StdRing.pin}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pin}}}
\pysigstopsignatures
\sphinxAtStartPar
Lista de restricciones PIN para cada elemento del anillo.

\end{fulllineitems}


\end{fulllineitems}

\index{clog2() (in module fpga.ring\_osc)@\spxentry{clog2()}\spxextra{in module fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.clog2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{clog2}}}{\sphinxparam{\DUrole{n}{N}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Numero de bits necesarios para especificar ‘N’ estados.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número del cual calcular la función ‘ceiling log’

\sphinxlineitem{Returns}
\sphinxAtStartPar
Número entero más pequeño que es mayor o igual al resultado del logaritmo base 2 de \sphinxtitleref{N}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (in module fpga.ring\_osc)@\spxentry{load()}\spxextra{in module fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.load}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{load}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
‘Wrapper’ para la función ‘load’ del módulo \sphinxtitleref{pickle}, que permite cargar un objeto guardado serializado de cualquier clase.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del archivo a cargar.

\end{description}\end{quote}

\end{fulllineitems}

\index{sim\_romatrix() (in module fpga.ring\_osc)@\spxentry{sim\_romatrix()}\spxextra{in module fpga.ring\_osc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fpga.ring_osc:fpga.ring_osc.sim_romatrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fpga.ring\_osc.}}\sphinxbfcode{\sphinxupquote{sim\_romatrix}}}{\sphinxparam{\DUrole{n}{N\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_pdl}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N\_osc}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_rep}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_pdl}\DUrole{o}{=}\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{std\_osc}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función proporciona un simulador naíf de una matriz de celdas; reproduce las medidas de una instancia para un número de repeticiones (N\_rep), pdl (N\_pdl) y celdas (N\_osc), así como ajustar las desviaciones estándar de cada proceso. El comportamiento estándar es: std\_rep\textless{}std\_pdl\textless{}std\_osc La función genera los valores aleatorios como una distribución normal, pero luego los escala para devolver siempre valores enteros positivos.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_rep}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de repeticiones simuladas.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de PDL simulados.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N\_osc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de celdas simuladas.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{std\_rep}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Desviación estándar de una misma celda, para un mismo PDL entre
medidas sucesivas.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{std\_pdl}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Desviación estandar de una misma celda entre distintos PDL

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{std\_osc}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Desviación estándar entre distintas celdas.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{setup module}
\label{\detokenize{setup:setup-module}}\label{\detokenize{setup::doc}}
\sphinxstepscope


\chapter{utils package}
\label{\detokenize{utils:module-utils}}\label{\detokenize{utils:utils-package}}\label{\detokenize{utils::doc}}\index{module@\spxentry{module}!utils@\spxentry{utils}}\index{utils@\spxentry{utils}!module@\spxentry{module}}\index{BarraProgreso (class in utils)@\spxentry{BarraProgreso}\spxextra{class in utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.BarraProgreso}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{BarraProgreso}}}{\sphinxparam{\DUrole{n}{total}}\sphinxparamcomma \sphinxparam{\DUrole{n}{long\_barra}\DUrole{o}{=}\DUrole{default_value}{40}}\sphinxparamcomma \sphinxparam{\DUrole{n}{caracter}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\#\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Esta clase instancia un objeto BarraProgreso.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{total}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de iteraciones que hacen el 100\% de la barra.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{long\_barra}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Número de caracteres que componen la barra, por defecto 40.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{caracter}} (\sphinxstyleliteralemphasis{\sphinxupquote{char}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Caracter que se utiliza para decorar la barra, por defecto ‘\#’.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{export\_legend\_plt() (in module utils)@\spxentry{export\_legend\_plt()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.export_legend_plt}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{export\_legend\_plt}}}{\sphinxparam{\DUrole{n}{ax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}legend.pdf\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pad\_inches}\DUrole{o}{=}\DUrole{default_value}{0.1}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Exporta la leyenda de la figura actualmente activa.

\sphinxAtStartPar
Esta función es útil para exportar la leyenda de un gráfico cuando se tienen
múltiples gráficos que comparten la misma leyenda. Es importante tener en cuenta
que se requiere haber creado una figura con ‘plt.plot’, la cual debe incluir una
leyenda, y NO se debe haber ejecutado ‘plt.show()’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxtitleref{matplotlib.axes.Axes}) \textendash{} Los ejes de la figura de los cuales se quiere extraer la leyenda. Si se utilizan
comandos como ‘plot’, etc., se puede obtener los ejes activos del gráfico con
ax=plt.gca().

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nombre de la imagen. Por defecto es “legend.pdf”.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pad\_inches}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Esta opción se pasa directamente a la función “savefig”. Por defecto es 0.1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Las opciones introducidas aquí se pasan directamente a la función \sphinxtitleref{ax.legend}.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_in\_parallel() (in module utils)@\spxentry{run\_in\_parallel()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.run_in_parallel}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{run\_in\_parallel}}}{\sphinxparam{\DUrole{n}{func}}\sphinxparamcomma \sphinxparam{\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Ejecuta la función en paralelo utilizando argumentos proporcionados.

\sphinxAtStartPar
Esta función toma un método ‘func’ y una lista de argumentos ‘args’, y repite la ejecución
de la función en paralelo. El método ‘func’ puede recibir un número arbitrario y tipos de argumentos,
pero serán pasados en orden según aparezcan en ‘args’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{func}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} Procedimiento que puede tomar un número arbitrario y tipos de argumentos, pero son específicos
en su posición.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Lista que contiene una lista con los argumentos a pasar a ‘func’ en cada proceso.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista con los resultados de cada proceso.

\sphinxlineitem{Return type}
\sphinxAtStartPar
list

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Esta función siempre debe ser ejecutada dentro de \sphinxtitleref{if \_\_name\_\_==’\_\_main\_\_’:}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{set\_size\_plt() (in module utils)@\spxentry{set\_size\_plt()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.set_size_plt}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{set\_size\_plt}}}{\sphinxparam{\DUrole{n}{ax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x}\DUrole{o}{=}\DUrole{default_value}{5.333333333333333}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}\DUrole{o}{=}\DUrole{default_value}{4}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función permite dibujar una figura fijando el tamaño del plot, y no de la figura completa. Toma los valores \sphinxtitleref{x}, \sphinxtitleref{y} que representan las dimensiones en dichos ejes de un plot, y construye la figura del tamaño que sea necesario para acomodar los ejes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxtitleref{matplotlib.axes.Axes}) \textendash{} Objeto que contiene la figura a redimensionar.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nueva anchura, por defecto 16/3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Nueva altura, por defecto 4.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}



\section{Submodules}
\label{\detokenize{utils:submodules}}
\sphinxstepscope


\subsection{utils.bool module}
\label{\detokenize{utils.bool:module-utils.bool}}\label{\detokenize{utils.bool:utils-bool-module}}\label{\detokenize{utils.bool::doc}}\index{module@\spxentry{module}!utils.bool@\spxentry{utils.bool}}\index{utils.bool@\spxentry{utils.bool}!module@\spxentry{module}}\index{LinearSystECC (class in utils.bool)@\spxentry{LinearSystECC}\spxextra{class in utils.bool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.LinearSystECC}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.bool.}}\sphinxbfcode{\sphinxupquote{LinearSystECC}}}{\sphinxparam{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{length}\DUrole{o}{=}\DUrole{default_value}{7}}\sphinxparamcomma \sphinxparam{\DUrole{n}{G}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{H}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Clase para manipular sistemas de códigos de corrección de errores lineales.

\sphinxAtStartPar
Esta clase proporciona funcionalidades para la generación de matrices G y H, codificación y decodificación de vectores para códigos de corrección de errores lineales en un cuerpo finito.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Dimensión de la matriz. Por defecto 4.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Longitud de la matriz. Por defecto 7.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Matriz booleana G para operaciones de generación de código. Por defecto False.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{H}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{opcional}}) \textendash{} Matriz booleana H para operaciones de generación de código. Por defecto False.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Si la matriz generadora y la matriz de paridad no cumplen GH\textasciicircum{}=0.

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta clase permite realizar operaciones en un cuerpo finito para códigos de corrección de errores lineales.
Los métodos ‘encode’ y ‘decode’ permiten la codificación y decodificación de vectores respectivamente,
usando las matrices generadora y de paridad.
\index{decode() (utils.bool.LinearSystECC method)@\spxentry{decode()}\spxextra{utils.bool.LinearSystECC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.LinearSystECC.decode}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{decode}}}{\sphinxparam{\DUrole{n}{vector}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Decodifica un código de entrada de ‘length’ bits en un mensaje de ‘dim’ bits
utilizando un método de mínima distancia de Hamming.

\sphinxAtStartPar
Este método es absolutamente ineficiente y no debería usarse con dimensiones
mayores que 9.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vector}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Código booleano de entrada a decodificar.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Mensaje decodificado.

\sphinxlineitem{Return type}
\sphinxAtStartPar
list of bool

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Si la longitud del vector de entrada no coincide con ‘length’.
    Si hay demasiados errores para decodificar el vector de manera fiable.

\end{description}\end{quote}

\end{fulllineitems}

\index{encode() (utils.bool.LinearSystECC method)@\spxentry{encode()}\spxextra{utils.bool.LinearSystECC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.LinearSystECC.encode}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{encode}}}{\sphinxparam{\DUrole{n}{vector}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Codifica un mensaje de entrada de ‘dim’ bits en un código de ‘length’ bits.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vector}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Mensaje booleano de entrada a codificar.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Mensaje booleano codificado.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Si la longitud del vector de entrada no coincide con ‘dim’.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{gauss\_elimination\_gf2() (in module utils.bool)@\spxentry{gauss\_elimination\_gf2()}\spxextra{in module utils.bool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.gauss_elimination_gf2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.bool.}}\sphinxbfcode{\sphinxupquote{gauss\_elimination\_gf2}}}{\sphinxparam{\DUrole{n}{coeff\_matrix\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{const\_vector\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Resuelve un sistema de ecuaciones booleanas en un cuerpo finito con las operaciones XOR (“+”) y AND (“*”).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_matrix\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Matriz booleana que representa los coeficientes del sistema de ecuaciones.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{const\_vector\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Vector booleano que representa el término independiente de cada ecuación.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Matriz booleana triangular.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{hamming() (in module utils.bool)@\spxentry{hamming()}\spxextra{in module utils.bool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.hamming}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.bool.}}\sphinxbfcode{\sphinxupquote{hamming}}}{\sphinxparam{\DUrole{n}{in1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{in2}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calcula la distancia de Hamming (medida en bits) entre dos entradas.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in1}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Primer vector booleano de entrada.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in2}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Segundo vector booleano de entrada.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Distancia de Hamming entre las dos entradas (medida en bits).

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{invert\_matrix\_gf2() (in module utils.bool)@\spxentry{invert\_matrix\_gf2()}\spxextra{in module utils.bool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.invert_matrix_gf2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.bool.}}\sphinxbfcode{\sphinxupquote{invert\_matrix\_gf2}}}{\sphinxparam{\DUrole{n}{matrix\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Devuelve la inversa de una matriz booleana en un cuerpo finito con las operaciones XOR (“+”) y AND (“*”).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matrix\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Matriz booleana a invertir.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Matriz booleana inversa.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{matrix\_multiply\_gf2() (in module utils.bool)@\spxentry{matrix\_multiply\_gf2()}\spxextra{in module utils.bool}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.bool:utils.bool.matrix_multiply_gf2}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.bool.}}\sphinxbfcode{\sphinxupquote{matrix\_multiply\_gf2}}}{\sphinxparam{\DUrole{n}{matrix1\_in}}\sphinxparamcomma \sphinxparam{\DUrole{n}{matrix2\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Multiplica un par de matrices booleanas en un cuerpo finito con las operaciones XOR (“+”) y AND (“*”).

\sphinxAtStartPar
Esta función puede utilizarse también para multiplicar vectores por matrices, gestionando automáticamente
la disposición del vector: fila si va delante de la matriz, columna si va detrás. Así, si ‘matrix1\_in’ y
‘matrix2\_in’ son dos vectores, el resultado será el producto vectorial.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matrix1\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Primera matriz booleana.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matrix2\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Segunda matriz booleana.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Producto de las matrices o el producto vectorial en gf(2).

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{utils.stats module}
\label{\detokenize{utils.stats:module-utils.stats}}\label{\detokenize{utils.stats:utils-stats-module}}\label{\detokenize{utils.stats::doc}}\index{module@\spxentry{module}!utils.stats@\spxentry{utils.stats}}\index{utils.stats@\spxentry{utils.stats}!module@\spxentry{module}}\index{Dks\_montecarlo\_discrete() (in module utils.stats)@\spxentry{Dks\_montecarlo\_discrete()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.Dks_montecarlo_discrete}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{Dks\_montecarlo\_discrete}}}{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fit}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calcula la distribución del estadístico KS de un modelo discreto en comparación con una distribución teórica.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{callable}}) \textendash{} Función aleatoria a contrastar. El primer parámetro que debe aceptar es ‘N’, seguido de un número arbitrario de
parámetros que son pasados mediante ‘kwargs’. Devuelve un array de valores aleatorios.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lista de valores que representa la distribución de probabilidad contra la cual se calcula la distribución de KS.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Número de veces que se repite el cálculo de Dks.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Si es True, imprime el progreso. Por defecto es True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Parámetros a pasar a ‘model’.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Lista de valores Dks.

\sphinxlineitem{Return type}
\sphinxAtStartPar
list of float

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función calcula la distribución del estadístico KS de un modelo ‘model’ que produce ‘N’ valores aleatorios frente a
una curva teórica ‘fit’, representada como una lista de valores. Devuelve una lista de estos índices KS.

\sphinxAtStartPar
El método ‘model’ admite una cantidad arbitraria de parámetros pasados mediante ‘kwargs’.

\end{fulllineitems}

\index{bin\_rv\_cont() (in module utils.stats)@\spxentry{bin\_rv\_cont()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.bin_rv_cont}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{bin\_rv\_cont}}}{\sphinxparam{\DUrole{n}{rv\_continuous}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bins\_in}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calcula la probabilidad acumulada de un objeto ‘rv\_continuous’ de scipy en los extremos dados por ‘bins’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rv\_continuous}} (\sphinxstyleliteralemphasis{\sphinxupquote{scipy.stats.rv\_continuous}}) \textendash{} Objeto ‘rv\_continuous’ de scipy.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bins\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Bineado del eje de abscisas. Debe ser una lista de ‘N\_bins+1’ elementos, conteniendo los extremos de cada bin.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Parámetros extra para pasar a ‘rv\_continuous.cdf’, distintos del primer argumento (‘x’).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Arreglo de tamaño ‘N\_bin’ elementos que contiene la probabilidad acumulada en los extremos dados por ‘bins’.
El arreglo de salida está normalizado respecto a la suma de sus elementos.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función toma un objeto ‘rv\_continuous’ de scipy y una lista ‘bins\_in’ que contiene el bineado del eje de abscisas.
Calcula la probabilidad acumulada en los extremos dados por ‘bins’ utilizando ‘rv\_continuous.cdf’ y devuelve un numpy array
normalizado con las probabilidades acumuladas.

\sphinxAtStartPar
El argumento ‘args’ se utiliza para pasar parámetros extra distintos al primero (‘x’) a ‘rv\_continuous.cdf’.

\end{fulllineitems}

\index{bin\_rv\_discrete() (in module utils.stats)@\spxentry{bin\_rv\_discrete()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.bin_rv_discrete}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{bin\_rv\_discrete}}}{\sphinxparam{\DUrole{n}{rv\_discrete}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bins\_in}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calcula la probabilidad acumulada de un objeto ‘rv\_discrete’ de scipy en los extremos dados por ‘bins’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rv\_discrete}} (\sphinxstyleliteralemphasis{\sphinxupquote{scipy.stats.rv\_discrete}}) \textendash{} Objeto ‘rv\_discrete’ de scipy.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bins\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Bineado del eje de abscisas. Debe ser una lista de ‘N\_bins+1’ elementos, conteniendo los extremos de cada bin.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Parámetros extra para pasar a ‘rv\_discrete’, distintos del primer argumento (‘k’).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Arreglo de tamaño ‘N\_bin’ elementos que contiene la probabilidad acumulada en los extremos dados por ‘bins’.
El arreglo de salida está normalizado respecto a la suma de sus elementos.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función toma un objeto ‘rv\_discrete’ de scipy y una lista ‘bins\_in’ que contiene el bineado del eje de abscisas.
Calcula la probabilidad acumulada en los extremos dados por ‘bins’ y devuelve un numpy array normalizado con las probabilidades acumuladas.

\sphinxAtStartPar
El argumento ‘args’ se utiliza para pasar parámetros extra distintos del primero (‘k’) a ‘rv\_discrete’.

\end{fulllineitems}

\index{chisq\_gof\_discrete() (in module utils.stats)@\spxentry{chisq\_gof\_discrete()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.chisq_gof_discrete}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{chisq\_gof\_discrete}}}{\sphinxparam{\DUrole{n}{obs\_data}}\sphinxparamcomma \sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.05}}\sphinxparamcomma \sphinxparam{\DUrole{n}{plothist}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Realiza un test chi\textasciicircum{}2 de bondad del ajuste entre los datos observados y un modelo
estocástico discreto (una función pmf \sphinxhyphen{}probability mass function\sphinxhyphen{}) que hipotéticamente
genera dichos datos.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Vector de datos observados.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{callable}}) \textendash{} Función pmf (probability mass function) que representa el modelo estocástico discreto.
El primer argumento siempre debe ser la variable independiente (aleatoria).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Nivel de significancia para el test chi\textasciicircum{}2. Por defecto es 0.05.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plothist}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Indica si se debe graficar el histograma de los datos. Por defecto es False.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Opciones adicionales para pasar parámetros a la función pmf introducida como modelo.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Un diccionario con los campos:
\sphinxhyphen{} ‘chisq’: Valor del estadístico chi\textasciicircum{}2.
\sphinxhyphen{} ‘pvalue’: Valor tal que la probabilidad de obtener ‘chisq’ es al menos pvalue.
\sphinxhyphen{} ‘dof’: Número de grados de libertad de la distribución chi\textasciicircum{}2.
\sphinxhyphen{} ‘testpass’: Booleano que indica si el test ha sido superado en función de ‘alpha’.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función calcula un test chi\textasciicircum{}2 de bondad del ajuste entre los datos observados y un modelo
estocástico discreto proporcionado como una función pmf. Se genera un histograma de los datos
y se calculan los valores esperados de probabilidad para cada bin. Luego se aplica la función
‘chisquare’ de scipy para realizar el test chi\textasciicircum{}2.

\sphinxAtStartPar
El parámetro ‘kwargs’ se puede utilizar para pasar parámetros adicionales a la función pmf del modelo.

\end{fulllineitems}

\index{fit\_rv\_cont() (in module utils.stats)@\spxentry{fit\_rv\_cont()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.fit_rv_cont}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{fit\_rv\_cont}}}{\sphinxparam{\DUrole{n}{data}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rv\_cont}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bins}\DUrole{o}{=}\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.05}}\sphinxparamcomma \sphinxparam{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Encuentra la distribución ‘rv\_continuous’ que mejor ajusta un conjunto de datos ‘data’ y calcula el ‘valor p’ correspondiente a una significancia ‘alpha’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Vector con los datos a ajustar.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rv\_cont}} (\sphinxstyleliteralemphasis{\sphinxupquote{scipy.stats.rv\_continuous}}) \textendash{} Objeto ‘scipy.stats.rv\_continuous’ que define una distribución de probabilidad continua que se ajustará a los datos ‘data’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bins}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Número de cajas para el histograma de ‘data’. Por defecto es 10.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Valor de significancia ‘alpha’ para el cual se calcula el valor p. Por defecto es 0.05.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Si es True, pinta el histograma y superpone la curva encontrada. La función no ejecuta ‘show()’, de forma que el usuario puede recabar la figura externamente
con ‘gca()’ y ‘gcf()’, y editarla antes de representarla. Por defecto es False.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Una lista que contiene cuatro elementos:
\sphinxhyphen{} El primero es una lista de los parámetros que mejor ajustan la distribución (en el mismo orden en que se definen en la función ‘rv\_cont.pdf’).
\sphinxhyphen{} El segundo es el valor ‘valo p’ correspondiente a una significancia ‘alpha’.
\sphinxhyphen{} El tercero es un nparray con el histograma.
\sphinxhyphen{} El cuarto es un nparray con el bineado de los datos de entrada.

\sphinxlineitem{Return type}
\sphinxAtStartPar
list

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función es un wrapper para encontrar la distribución ‘rv\_continuous’ que mejor ajusta un conjunto de valores ‘data’ utilizando la máxima verosimilitud.
Calcula el ‘valor p’ correspondiente a una significancia ‘alpha’. Resulta útil para distribuciones obtenidas por simulación, que carecen de una función
densidad teórica.

\end{fulllineitems}

\index{get\_area\_fraction() (in module utils.stats)@\spxentry{get\_area\_fraction()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.get_area_fraction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{get\_area\_fraction}}}{\sphinxparam{\DUrole{n}{hist}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p}\DUrole{o}{=}\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Encuentra los extremos ‘xmin’ y ‘xmax’ de una lista ‘hist’ de números (no necesariamente normalizada)
de tal manera que el intervalo ‘hist{[}xmin:xmax{]}’ contenga al menos una fracción ‘p’ de la suma acumulada
de los elementos de la lista.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hist}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Lista de números.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Fracción mínima deseada. Por defecto es 0.9.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xmin} (\sphinxstyleemphasis{int}) \textendash{} Índice del extremo izquierdo del intervalo.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{xmax} (\sphinxstyleemphasis{int}) \textendash{} Índice del extremo derecho del intervalo.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función busca los extremos ‘xmin’ y ‘xmax’ en la lista ‘hist’ de números, de tal manera que el intervalo
‘hist{[}xmin:xmax{]}’ contenga al menos una fracción ‘p’ de la suma acumulada de los elementos de la lista. La búsqueda
comienza desde el índice correspondiente al valor máximo de la lista y se desplaza simétricamente hacia ambos extremos.

\end{fulllineitems}

\index{get\_hist\_smooth() (in module utils.stats)@\spxentry{get\_hist\_smooth()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.get_hist_smooth}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{get\_hist\_smooth}}}{\sphinxparam{\DUrole{n}{data}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p}\DUrole{o}{=}\DUrole{default_value}{0.9}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x0}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{x1}\DUrole{o}{=}\DUrole{default_value}{nan}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Genera un histograma suavizado a partir de un conjunto de datos ‘data’.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Conjunto de datos para representar en forma de histograma.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Fracción (tanto por uno) de área bajo la cual se busca que el histograma no presente máximos relativos.
Por defecto es 0.9.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x0}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Extremo inferior del rango del histograma. Por defecto es NaN (se calcula automáticamente a partir de ‘data’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Extremo superior del rango del histograma. Por defecto es NaN (se calcula automáticamente a partir de ‘data’).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Histograma suavizado generado.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Esta función devuelve un histograma con el número de bins adecuado para que no presente máximos locales,
lo cual resulta en un aspecto más suave. El parámetro ‘p’ representa la fracción de área bajo la cual
se busca que el histograma no presente máximos relativos, medido simétricamente desde el punto máximo
del histograma.

\sphinxAtStartPar
Los parámetros ‘x0’ y ‘x1’ son opcionales y se utilizan para definir el rango del histograma; si no se
proporcionan, se calculan automáticamente a partir de los valores mínimo y máximo de ‘data’.

\end{fulllineitems}

\index{intervalo\_int() (in module utils.stats)@\spxentry{intervalo\_int()}\spxextra{in module utils.stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.stats:utils.stats.intervalo_int}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.stats.}}\sphinxbfcode{\sphinxupquote{intervalo\_int}}}{\sphinxparam{\DUrole{n}{inf}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sup}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función auxiliar devuelve los extremos de números enteros dado un intervalo real.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inf}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Extremo inferior del intervalo.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sup}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Extremo superior del intervalo.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Rango de enteros entre los extremos \sphinxtitleref{inf} y \sphinxtitleref{sup}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
list

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{utils.tensor module}
\label{\detokenize{utils.tensor:module-utils.tensor}}\label{\detokenize{utils.tensor:utils-tensor-module}}\label{\detokenize{utils.tensor::doc}}\index{module@\spxentry{module}!utils.tensor@\spxentry{utils.tensor}}\index{utils.tensor@\spxentry{utils.tensor}!module@\spxentry{module}}
\sphinxAtStartPar
Este módulo permite definir nombres para los ejes
de un numpyarray.
\index{Tensor (class in utils.tensor)@\spxentry{Tensor}\spxextra{class in utils.tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{utils.tensor.}}\sphinxbfcode{\sphinxupquote{Tensor}}}{\sphinxparam{\DUrole{n}{array}}\sphinxparamcomma \sphinxparam{\DUrole{n}{axis}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Un objeto que es esencialmente un nparray junto con una variable ‘self.axis’ que permite indexar los ejes del array mediante un nombre natural, en lugar de un índice entero.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arreglo que contiene los datos y la forma del tensor.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{strings}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Nombres de los ejes. El orden en que se proporcionan los nombres se correlaciona
con el correspondiente eje del parámetro ‘array’. Si no se introduce una lista de nombres en esta variable,
se asignarán por defecto como nombres el índice de cada eje (empezando en ‘0’).

\end{itemize}

\end{description}\end{quote}
\index{array (utils.tensor.Tensor attribute)@\spxentry{array}\spxextra{utils.tensor.Tensor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.array}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{array}}}
\pysigstopsignatures
\sphinxAtStartPar
Arreglo que contiene los datos y la forma del tensor.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{shape (utils.tensor.Tensor attribute)@\spxentry{shape}\spxextra{utils.tensor.Tensor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.shape}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{shape}}}
\pysigstopsignatures
\sphinxAtStartPar
Forma del tensor (igual que en un nparray).
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{axis (utils.tensor.Tensor attribute)@\spxentry{axis}\spxextra{utils.tensor.Tensor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.axis}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{axis}}}
\pysigstopsignatures
\sphinxAtStartPar
Nombres de los ejes. El i\sphinxhyphen{}ésimo elemento contiene el nombre del i\sphinxhyphen{}ésimo eje.
Si no se proporciona, se asignan nombres predeterminados en forma de índices.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
list of strings

\end{description}\end{quote}

\end{fulllineitems}

\index{item() (utils.tensor.Tensor method)@\spxentry{item()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.item}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{item}}}{\sphinxparam{\DUrole{o}{**}\DUrole{n}{axes}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función toma por argumento el nombre de cada eje igualado a un
índice, y devuelve el valor guardado en esa coordenada.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axes}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Argumentos clave\sphinxhyphen{}valor donde las claves son los nombres de los ejes y
los valores son los índices para esos ejes.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Valor almacenado en las coordenadas especificadas.

\sphinxlineitem{Return type}
\sphinxAtStartPar
object

\end{description}\end{quote}

\end{fulllineitems}

\index{mean() (utils.tensor.Tensor method)@\spxentry{mean()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.mean}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mean}}}{\sphinxparam{\DUrole{n}{axe}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Devuelve un Tensor comprimido en el eje ‘axe’, suprimiéndolo y calculando el promedio a lo largo de dicho eje.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axe}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Índice del eje a comprimir y calcular el promedio.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor con el eje ‘axe’ suprimido y cada punto contiene el promedio a lo largo de ese eje.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (utils.tensor.Tensor method)@\spxentry{save()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\sphinxparam{\DUrole{n}{file\_name}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fmt}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\%.18e\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Guarda el Tensor en un archivo de texto.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del archivo donde se guardará el Tensor.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fmt}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Formato numérico de los datos. Sigue el mismo formato que el parámetro ‘fmt’
de numpy.savetxt.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{size() (utils.tensor.Tensor method)@\spxentry{size()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.size}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{size}}}{\sphinxparam{\DUrole{n}{axis}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Esta función toma el nombre de un eje y devuelve su dimensión.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del eje del que se desea obtener la dimensión.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Dimensión del eje especificado.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{slice() (utils.tensor.Tensor method)@\spxentry{slice()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.slice}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{slice}}}{\sphinxparam{\DUrole{o}{**}\DUrole{n}{axes}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Toma una serie de ejes (por nombre), igualados a una porción ‘slice’. Esta porción puede ser
un entero, una lista de dos enteros, o una lista de tres enteros, y devuelve un Tensor reducido al ‘slice’
indicado (usando la misma notación que un slice estándar en Python: {[}x{]} es la x\sphinxhyphen{}ésima entrada, {[}x,y{]} son
todas entradas en {[}x,y), y {[}x,y,z{]} son todas las entradas en {[}x,y) tomadas en saltos de z). Esta función
es en realidad un wrapper a ‘take’, usando la nomenclatura de Python para hacer slicing.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axes}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Argumentos clave\sphinxhyphen{}valor donde las claves son los nombres de los ejes y los valores
son objetos ‘slice’ o listas de enteros para realizar la porción en esos ejes.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor reducido al ‘slice’ indicado a lo largo de los ejes especificados.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{squeeze() (utils.tensor.Tensor method)@\spxentry{squeeze()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.squeeze}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{squeeze}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Elimina todos los ejes del tensor cuya dimensión sea igual a ‘1’.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor resultante después de eliminar los ejes con dimensión ‘1’.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{std() (utils.tensor.Tensor method)@\spxentry{std()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.std}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{std}}}{\sphinxparam{\DUrole{n}{axe}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Devuelve un Tensor comprimido en el eje ‘axe’, suprimiéndolo y calculando la desviación estándar a lo largo de dicho eje.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axe}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Índice del eje a comprimir y calcular la desviación estándar.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor con el eje ‘axe’ suprimido y cada punto contiene la desviación estándar a lo largo de ese eje.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap() (utils.tensor.Tensor method)@\spxentry{swap()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.swap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{swap}}}{\sphinxparam{\DUrole{n}{axe1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{axe2}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Devuelve un Tensor con el mismo “array” pero los ejes “axe1” y “axe2” intercambiados.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axe1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Índice del primer eje a intercambiar.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axe2}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Índice del segundo eje a intercambiar.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor con los ejes “axe1” y “axe2” intercambiados.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{take() (utils.tensor.Tensor method)@\spxentry{take()}\spxextra{utils.tensor.Tensor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.Tensor.take}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{take}}}{\sphinxparam{\DUrole{o}{**}\DUrole{n}{axes}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Toma una serie de ejes (por nombre), igualados a una lista de índices, y devuelve un Tensor
reducido a los índices seleccionados.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axes}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Argumentos clave\sphinxhyphen{}valor donde las claves son los nombres de los ejes y los valores
son listas de índices a lo largo de esos ejes.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor reducido a los índices seleccionados a lo largo de los ejes especificados.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{append() (in module utils.tensor)@\spxentry{append()}\spxextra{in module utils.tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.append}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.tensor.}}\sphinxbfcode{\sphinxupquote{append}}}{\sphinxparam{\DUrole{n}{axe}}\sphinxparamcomma \sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Concatena dos objetos ‘Tensor’ a lo largo de un eje especificado por su nombre.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axe}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del eje a lo largo del cual se realizará la concatenación.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} ({\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Tensor}}}}}) \textendash{} Tensores que se concatenarán. Se deben proporcionar al menos dos tensores de entrada.
Todos los tensores deben tener un parámetro ‘Tensor.axis’ idéntico y las mismas
dimensiones en todos los ejes excepto posiblemente en ‘axe’.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Nuevo Tensor que consiste en la concatenación de los argumentos en el orden proporcionado.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} Si no se cumplen los requisitos de entrada (al menos dos tensores y ‘axe’).

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_tensor() (in module utils.tensor)@\spxentry{load\_tensor()}\spxextra{in module utils.tensor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils.tensor:utils.tensor.load_tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.tensor.}}\sphinxbfcode{\sphinxupquote{load\_tensor}}}{\sphinxparam{\DUrole{n}{file\_name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Devuelve un Tensor almacenado en un archivo de texto.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nombre del archivo que contiene el Tensor.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Tensor cargado desde el archivo de texto.

\sphinxlineitem{Return type}
\sphinxAtStartPar
{\hyperref[\detokenize{utils.tensor:utils.tensor.Tensor}]{\sphinxcrossref{Tensor}}}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{fpga}\sphinxstyleindexpageref{fpga:\detokenize{module-fpga}}
\item\relax\sphinxstyleindexentry{fpga.fabric}\sphinxstyleindexpageref{fpga.fabric:\detokenize{module-fpga.fabric}}
\item\relax\sphinxstyleindexentry{fpga.interfaz\_pcps}\sphinxstyleindexpageref{fpga.interfaz_pcps:\detokenize{module-fpga.interfaz_pcps}}
\item\relax\sphinxstyleindexentry{fpga.ring\_osc}\sphinxstyleindexpageref{fpga.ring_osc:\detokenize{module-fpga.ring_osc}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utils}\sphinxstyleindexpageref{utils:\detokenize{module-utils}}
\item\relax\sphinxstyleindexentry{utils.bool}\sphinxstyleindexpageref{utils.bool:\detokenize{module-utils.bool}}
\item\relax\sphinxstyleindexentry{utils.stats}\sphinxstyleindexpageref{utils.stats:\detokenize{module-utils.stats}}
\item\relax\sphinxstyleindexentry{utils.tensor}\sphinxstyleindexpageref{utils.tensor:\detokenize{module-utils.tensor}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}