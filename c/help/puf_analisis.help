 Programa de simulacion y analisis de PUF de medida compensada: este programa genera (o lee) una matriz de celdas PUF y utiliza un esquema de comparaciones (topologia de la PUF) para producir una respuesta binaria. El proceso de fabricacion se simula mediante una distribucion de probabilidad normal. El programa admite un gradiente de correlacion espacial. Alternativamente a la generacion Monte Carlo de medidas puede introducirse un archivo externo con la opcion '-in' adecuadamente. Cuando una opcion incluye parametros opcionales estos se incluyen entre corchetes []. Si son mutuamente exclusivos se separan por '|'. Por defecto una opcion toma los primeros parametros que aparecen en la lista de opciones, e.g., la opcion '-out' sin subopciones equivale a '-out r rawdata_out.mtz' formateado
-------------------------------------------

Opciones:

 * [mpfr_precision]
	flag especial para indicar el numero de bits de precision utilizado por la biblioteca 'mpfr'. Por defecto se
	utilizan 53 bits


 -in [raw(r) | dist(d) | pufexp(x)]
	esta opcion permite leer datos de un fichero de entrada.

	raw(r) [rawdata.mtz]
		lee un fichero en formato .mtz con nx*ny columnas, ninst*nrep*npdl filas desdobladas Ninst(Nrep(Npdl)).
		En caso de faltar todas (o algunas) de estas opciones, el programa procede de la siguiente manera:
			Si faltan todas se toma por defecto Nrep = N_filas de la entrada (y el resto =1).
			Si solo se da '-nrep' se toma Ninst=N_filas/Nrep (y el resto =1).
			Si solo se da '-ninst' se toma Nrep=N_filas/Ninst (y el resto =1).
			Si solo se da '-npdl' se toma Nrep=N_filas/Npdl (y el resto =1).
			Si se dan dos opciones cualesquiera (Na, Nb), la tercera se calcula como Nc=N_filas/(Na*Nb).

			En cualquier caso los numeros introducidos deben permitir 'doblar' el numero de columnas leidas en 
			un array de tres dimensiones, en caso contrario el programa terminara con un error. Al introducir 
			los datos en crudo, podemos construir nosotros la respuesta PUF utilizando alguna de las 
			topologias propuestas (el programa es sensible a la opcion '-topol', ver mas abajo), 
			introduciendo el numero de retos '-nretos' deseado. Ademas, si asignamos unas cantidades '-nx' y/o 
			'-ny' el programa podra construir el mapa de frecuencias utilizando la opcion '-out hm' (ver mas 
			abajo). Además, podemos utilizar las PDL como retos construyendo 'pufexp' y doblándolo de la 
			manera adecuada utilizando '-resize_pufexp'.

	dist(d)[dist.mtz]
		esta subopcion permite introducir una distribucion de valores; el formato de entrada sera una matriz 
		.mtz, pero se esparea que tenga solo una columna y todos los valores se distribuyan en una sola fila. 
		Esta opcion es util unicamente para realizar algunos analisis estadisticos, como dibujar histogramas 
		o calcular entropias. No permite ningun tipo de simulacion o postprocesamiento PUF.

	pufexp(x) [pufexp.pex]
		esta subopcion permite introducir un experimento PUF en formato .pex; en este caso el programa 
		ignorara las opciones -Nretos, -Ninst, -Nrep y -topol: unicamente podremos realizar el analisis de 
		los datos leidos.
		Notar que si se indican ambas opciones, primero se realiza el desdoblamiento y solo despues el 
		truncamiento.

	En ausencia de cualquier subopcion se toma -in = -in r rawdata.mtz


 -out [raw(r)]  [dist(d)]  [pufexp(x)] [map(m)] [hist(h)]
	esta opcion controla los ficheros de salida.

	raw(r) ["rawdata_out.mtz"]
		escribe un fichero en formato .mtz con Nx*Ny columnas, Nretos*Ninst*Nrep filas (desdobladas 
		Nretos{Ninst{Nrep}}). Esta subopcion se ignora si se utiliza la opcion '-in'.

	dist(d) ["dist_out.mtz"]
		escribe la distribucion de palabras binarias simuladas (si no hay opcion '-in'), o introducidas (si se 
		utiliza la opcion '-in r | -in x'). Esta subopcion se ignora si se utiliza '-in d'.

	pufexp(x) ["pufexp_out.pex"]
		escribe un experimento PUF en formato '.pex' para una simulacion PUF o un fichero 'rawdata'. Esta 
		subopcion se ignora si se utiliza '-in d | -in x'.
		Notar que si se indican ambas opciones, primero se realiza el desdoblamiento y solo despues el 
		truncamiento.

	map(m) ["map.txt"]
		escribe el array de celdas para la primera instancia PUF para una simulacion PUF o si se utiliza la 
		entrada '-in r'. Esta subopcion se ignora si se utiliza '-in d | -in x'

	hist(h) ["histograma.txt"] [caja] [xmin] [xmax] [resolucion] [sspace] [norm]
		escribe el histograma de la distribucion (simulada o introducida).
		Admite una serie de subopciones:

		caja [f] 1.0,
			con esta opcion se introduce el tamano de la caja. Si la opcion no esta presente, el tamano se 
			calcula automaticamente utilizando la regla de Friedmann-Diaconis. Si se escribe el caracter 'f' 
			delante de un numero (real), entonces dicho numero real se utilizara como factor multiplicativo 
			sobre el tamano decaja calculado automaticamente mediante la regla de Friedmann-Diaconis. Notar que
			en el metodo 'sspace' la caja se ignora

		xmin -1.0,
			esta opcion permite fijar el extremo inferior del histograma. Si se introduce un valor negativo 
			(por defecto) el extremo se calcula automaticamente a partir de los datos.

		xmax -1.0,
			esta opcion permite fijar el extremo superior del histograma. Si se introduce un valor negativo 
			(por defecto) el extremo se calcula automaticamente a partir de los datos

		resolucion 6,
			esta cantidad es el numero de cifras decimales de la distribucion de entrada. Para valores 'float' 
			este valor es '6'.
			Si la distribucion proviene de una conversion binaria->decimal, la resolucion sera '0'. Esta opcion
			solo es relevante para el metodo 'sspace'.

		sspace,
			si esta opción está presente se modifica el algoritmo utilizado para construir el histograma 
			(sampling space).
			'sspace' ignora el tamano de caja, y solo debe utilizarse sobre espacios compactos.

		norm [area | alt],
			esta opcion controla la normalización del histograma (por area o por el valor maximo).


 -resize_pufexp(resx) 1,1,1,1
	esta opcion permite doblar o desdoblar las respuestas para conseguir un menor numero de respuestas de mayor
	longitud, o mas respuestas de menor longitud (respectivamente). Una vez indicada esta opcion es obligatorio
	incluir cuatro numeros enteros separados por una coma que indican 
	nuevo_N_retos,nuevo_N_inst,nuevo_N_rep,nuevo_tamano_respuesta. El producto de estas cuatro cantidades debe 
	ser igual que en el fichero 'pufexp' original.


 -truncate_pufexp(trux) -1
	esta opcion permite truncar las bitwrds de entrada, modificando el tamano de las respuestas al numero 
	entero indicado a continuacion.
	Si este numero es negativo (por defecto), esta opcion se ignora.


 -geom [nx] [ny]
	geometria de la instancia PUF.
	Eta opcion se ignora si se utiliza '-in d | -in x'.

	nx [1]
		tamano de la matriz PUF en la direccion X.

	ny [1]
		tamano de la matriz PUF en la direccion Y.


 -sim [frec ] [desv] [fcorr] [ftemp],
	esta opcion controla algunos parametros de la simulacion, por lo tanto se ignora si se uitiliza '-in'.

	frec [100.0]
		frecuencia nominal promedio para la simulacion (en MHz).

	desv [1.0]
		desviacion de la frecuencia nominal en cada array de celdas.

	fcorr [lineal_x | lineal_xy | producto_xy]
		factor de correlación entre los valores de distintas celdas.
		Pueden utilizarse diversos tipos de correlacion:

		lineal_x [1.0]
			el valor medio de la distribucion depende de la coordenada X multiplicada por 'factor.

		lineal_xy [1.0] [1.0]
			el valor medio de la distribucion depende de la suma de las coordenadas X,Y ponderadas 
			respectivamente por 'factor_x' y 'factor_y'.

		producto_xy [1.0]
			el valor medio de la distribución se multiplica por las coordenadas X*Y y por 'factor'.

	ftemp [0.0]
		cte de acoplo termico, esta cantidad se utiliza como varianza de una distribucion aleatoria que 
		modifica el valor nominal de las celdas simuladas.


 -nretos [1],
	numero de retos (permutaciones) utilizadas para cada instancia.
	Esta opcion se ignora si se utilizan las entradas '-in d | -in x'.


 -ninst [1],
	numero de instancias simuladas.
	Esta opcion se ignora si se utilizan las entradas '-in d | -in x'


 -nrep [1],
	numero de repeticiones medidas para cada reto e instancia.
	Esta opcion se ignora si se utilizan las entradas '-in d | -in x'


 -npdl [1],
	numero de valores proporcionados por cada oscilador (reconfigurabilidad del oscilador).
	Esta opcion se ignora si se utilizan las entradas '-in d | -in x'


 -nprec [1],
	precision de la medida comparativa medido en numero de bits. Si Nprec = 1 solo se medira el signo de la 
	comparacion.
	Esta opcion se ignora si se utilizan las entradas '-in d | -in x'.


 -puf [ringoscillator(ro) | arbiter(a)]
	esta opcion permite elegir que clase de PUF simular. Se ignora si '-in d | x'.
	Ademas la forma en que se interpreta '-in r' puede cambiar.

	ringoscillator(ro) [n-1 | 1o2 | ap | km | c1 | file | rp]
		Simula RO-PUF. Los retos se componen de la sucesion de parejas utilizadas en la comparacion (sin 
		normalizar por el numero de osciladores).
		La subopcion que sigue permite cambiar la forma en que se comparan pares de osciladores:
		
		n-1
			(explicacion)

		1o2
			(explicacion)

		ap
			(explicacion)

		km [3]
			esta opcion debe ir acompanada del valor 'k' (por defecto k=3)

		c1
			(explicacion)

		file [topol.cmt]
			esta opcion carga una topologia predefinada en el archivo 'topol.cmt'

		rp [1]
			esta opcion hace que cada reto se construya como una serie de pares de celdas (por defecto 1 par) 
			tomadas al azar, y la respuesta constara de los bits correspondientes (por defecto 1 bit).

	arbiter(a)
		Simula una Arbiter-PUF.


 -pufanalysis(pa) [intradist] [interdist] [far] [frr] [eer] [roc]

	intradist [hist(h)] [dist(d)] [ajuste(a)]
		(contenido de intradist).

		hist(h) ["intrad_hist.txt"] [caja] [xmin] [xmax]
			(contenido de hist). Ver '-in h' para una explicacion de las subopciones.
		
			caja 1.0
				ver la subopción 'caja' en '-in h'
			
			xmin -1.0
				ver la subopción 'xmin' en '-in h'
			
			xmax -1.0
				ver la subopción 'xmax' en '-in h'

		dist(d) ["intrad_dist.mtz"]
			(distribucion)

		ajuste(a) ["intrad_ajuste.txt"]
			(ajuste)

	interdist [hist(h)] [dist(d)] [ajuste(a)]
		(Expicacion inter-distancia: analogo a intra-distancia).
		
		hist(h) ["interd_hist.txt"] [caja] [xmin] [xmax]
		
			caja 1.0
				ver la subopción 'caja' en '-in h'
			
			xmin -1.0
				ver la subopción 'xmin' en '-in h'
			
			xmax -1.0
				ver la subopción 'xmax' en '-in h'
				
		dist(d) ["interd_dist.mtz"]
			(distribucion)

		ajuste(a) ["interd_ajuste.txt"]
			(ajuste)

	far [far.txt]
		(explicacion FAR).

	frr [frr.txt]
		(explicacion frr).

	eer
		(explicacion EER).

	roc [roc.txt]
		explicacion ROC.


 -adversario(adv) [ignorant(i) | global_bias(gb) | local_bias(lb) | machine_learning(ml)] [ntrials] [umbral_id]
	esta opcion permite configurar varios niveles de un adversario que trata de romper la PUF.
	'Romper la PUF' es crear un modelo matematico eficaz de la PUF. Un 'modelo eficaz' de la PUF es aquel capaz
	de generar respuestas a retos con un margen de error respecto de la respuesta legitima x<y, donde 'y' es el
	umbral de identificacion de un sistema de identificacion PUF. Esta opcion se ignora si se utiliza la 
	entrada '-in d'

	ignorant(i)
		el adversario ignora por completo la distribucion subyacente de las respuestas, y lo mejor que puede 
		hacer es advinar bits al azar.

	global_bias(gb) [1]
		el adversario conoce el sesgo global de las respuestas hacia 0_n -> 1_n, donde 'X_n' es la palabra de 
		'n' digitos 'X', y 'n' es el valor de la subopcion (1 por defecto). El adversario genera un conjunto de
		respuestas binarias que reproduzcan este sego.

	local_bias(lb) [1]
		el adversario conoce el sesgo en relacion a su posicion en la palabra binaria de las respuestas hacia 
		0_n -> 1_n (1 por defecto). El adversario genera un conjunto de respuestas binarias que reproduzcan 
		este sego.

	machine_learning(ml)
		Esta opcion genera un archivo '.py' con el codigo necesario para implementar una red neuronal en 
		tf-keras; esta red se entrena con una sucesion de i-1 bits, y trata de adivinar el i-esimo bit.

	ntrials 1
		esta opcion permite cambiar el numero de intentos de acceso ilegitimo del adversario. Una vez 
		determinado el modelo de adversario, este generara 'ntrials' repeticiones para cada instancia y cada 
		reto. Se calcula la HD promedio entre cada repeticion y el conjunto de repeticiones proporcionadas a la
		entrada para cada instancia y reto. Si HD promedio es menor que el umbral de identificacion el acceso 
		es positivo, en caso contrario negativo.

	umbral_id -1.0
		Esta opcion permite modificar el umbral de identificacion. Si se introduce un valor negativo (por 
		defecto) el umbral se calcula automaticamente para EER (equal error rate). Introducir un valor en tanto
		por ciento (entre 0.0 y 100.0).


 -entropia [pb] [pn]
	si esta opcion esta presente el programa devolvera la entropia de la distribucion. Por defecto se calcula
	la entropia de Shannon.

	pb
		calcula la entropia por bit de la respuesta.

	pn
		calcula la entropia por celda de la respuesta.


 -minentropia
	si esta opcion esta presente el programa devolvera la minentropia de la distribucion.


 -nv
	si esta opcion esta presente el programa no pinta barras de progreso. Esta opcion se utiliza para lanzar el
	programa dentro de un script


 -gsort
	si esta opcion esta presente se utilizaran las funciones de la biblioteca GSL para ordenar arreglos. En 
	caso contrario se utilizara el algoritmo 'quickSort'. El metodo GSL es mucho mas rapido pero consume mas 
	memoria


